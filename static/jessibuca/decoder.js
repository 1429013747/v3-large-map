!(function (e, r) { typeof exports == "object" && typeof module != "undefined" ? r(require("node:path"), require("node:fs"), require("node:crypto")) : typeof define == "function" && define.amd ? define(["path", "fs", "crypto"], r) : r((e = typeof globalThis != "undefined" ? globalThis : e || self).path, e.fs, e.crypto$1) }(this, (e, r, t) => {
  "use strict"; function n(e) { return e && typeof e == "object" && "default" in e ? e : { default: e } } const o = n(e); const i = n(r); const a = n(t); function s(e, r) { return e(r = { exports: {} }, r.exports), r.exports } const l = s((e) => {
    var r = void 0 !== r ? r : {}; let t = (r = { print(e) { console.log("Jessibuca: [worker]:", e) }, printErr(e) { console.warn("Jessibuca: [worker]:", e), postMessage({ cmd: "wasmError", message: e }) } }, Object.assign({}, r)); let n = "./this.program"; const s = typeof window == "object"; const l = typeof importScripts == "function"; const u = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string"; const c = !s && !u && !l; if (r.ENVIRONMENT) throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)"); let d; let f; let p; let m; let h; let g; let v = ""; if (u) { if (typeof process != "object") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"); v = l ? `${o.default.dirname(v)}/` : `${__dirname}/`, g = () => { h || (m = i.default, h = o.default) }, d = function (e, r) { return g(), e = h.normalize(e), m.readFileSync(e, r ? void 0 : "utf8") }, p = (e) => { let r = d(e, !0); return r.buffer || (r = new Uint8Array(r)), F(r.buffer), r }, f = (e, r, t) => { g(), e = h.normalize(e), m.readFile(e, (e, n) => { e ? t(e) : r(n.buffer) }) }, process.argv.length > 1 && (n = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), e.exports = r, process.on("uncaughtException", (e) => { if (!(e instanceof St)) throw e }), process.on("unhandledRejection", (e) => { throw e }), r.inspect = function () { return "[Emscripten Module object]" } }
    else if (c) { if (typeof process == "object" || typeof window == "object" || typeof importScripts == "function") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"); typeof read != "undefined" && (d = function (e) { return read(e) }), p = function (e) { let r; return typeof readbuffer == "function" ? new Uint8Array(readbuffer(e)) : (r = read(e, "binary"), F(typeof r == "object"), r) }, f = function (e, r, t) { setTimeout(() => r(p(e)), 0) }, typeof scriptArgs != "undefined" && scriptArgs, typeof print != "undefined" && (typeof console == "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr != "undefined" ? printErr : print) }
    else { if (!s && !l) throw new Error("environment detection error"); if (l ? v = self.location.href : typeof document != "undefined" && document.currentScript && (v = document.currentScript.src), v = v.indexOf("blob:") !== 0 ? v.substr(0, v.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", typeof window != "object" && typeof importScripts != "function") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"); d = (e) => { const r = new XMLHttpRequest(); return r.open("GET", e, !1), r.send(null), r.responseText }, l && (p = (e) => { const r = new XMLHttpRequest(); return r.open("GET", e, !1), r.responseType = "arraybuffer", r.send(null), new Uint8Array(r.response) }), f = (e, r, t) => { const n = new XMLHttpRequest(); n.open("GET", e, !0), n.responseType = "arraybuffer", n.onload = () => { n.status == 200 || n.status == 0 && n.response ? r(n.response) : t() }, n.onerror = t, n.send(null) } } let y; let E; let w; const b = r.print || console.log.bind(console); const _ = r.printErr || console.warn.bind(console); function T(e) { T.shown || (T.shown = {}), T.shown[e] || (T.shown[e] = 1, _(e)) } function k(e, t) { Object.getOwnPropertyDescriptor(r, e) || Object.defineProperty(r, e, { configurable: !0, get() { ge(`Module.${e} has been replaced with plain ${t} (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)`) } }) } function S(e, r) { let t = `'${e}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)`; return r && (t += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), t } function C(e, t) { Object.getOwnPropertyDescriptor(r, e) || Object.defineProperty(r, e, { configurable: !0, get() { ge(S(e, t)) } }) } function P(e, t) { Object.getOwnPropertyDescriptor(r, e) || (r[e] = () => ge(S(e, t))) }Object.assign(r, t), t = null, y = "fetchSettings", Object.getOwnPropertyDescriptor(r, y) && ge(`\`Module.${y}\` was supplied but \`${y}\` not included in INCOMING_MODULE_JS_API`), r.arguments, k("arguments", "arguments_"), r.thisProgram && (n = r.thisProgram), k("thisProgram", "thisProgram"), r.quit, k("quit", "quit_"), F(void 0 === r.memoryInitializerPrefixURL, "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"), F(void 0 === r.pthreadMainPrefixURL, "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"), F(void 0 === r.cdInitializerPrefixURL, "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"), F(void 0 === r.filePackagePrefixURL, "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"), F(void 0 === r.read, "Module.read option was removed (modify read_ in JS)"), F(void 0 === r.readAsync, "Module.readAsync option was removed (modify readAsync in JS)"), F(void 0 === r.readBinary, "Module.readBinary option was removed (modify readBinary in JS)"), F(void 0 === r.setWindowTitle, "Module.setWindowTitle option was removed (modify setWindowTitle in JS)"), F(void 0 === r.TOTAL_MEMORY, "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"), k("read", "read_"), k("readAsync", "readAsync"), k("readBinary", "readBinary"), k("setWindowTitle", "setWindowTitle"), F(!c, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable."), r.wasmBinary && (E = r.wasmBinary), k("wasmBinary", "wasmBinary"), r.noExitRuntime, k("noExitRuntime", "noExitRuntime"), typeof WebAssembly != "object" && ge("no native wasm support detected"); let A = !1; function F(e, r) { e || ge(`Assertion failed${r ? `: ${r}` : ""}`) } const D = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0; function O(e, r, t) {
      for (var n = r + t, o = r; e[o] && !(o >= n);)++o; if (o - r > 16 && e.buffer && D) return D.decode(e.subarray(r, o)); for (var i = ""; r < o;) {
        let a = e[r++]; if (128 & a) {
          const s = 63 & e[r++]; if ((224 & a) != 192) {
            const l = 63 & e[r++]; if ((240 & a) == 224 ? a = (15 & a) << 12 | s << 6 | l : ((248 & a) != 240 && T(`Invalid UTF-8 leading byte 0x${a.toString(16)} encountered when deserializing a UTF-8 string in wasm memory to a JS string!`), a = (7 & a) << 18 | s << 12 | l << 6 | 63 & e[r++]), a < 65536) {
              i += String.fromCharCode(a);
            }
            else { const u = a - 65536; i += String.fromCharCode(55296 | u >> 10, 56320 | 1023 & u) }
          }
          else {
            i += String.fromCharCode((31 & a) << 6 | s)
          }
        }
        else {
          i += String.fromCharCode(a)
        }
      } return i
    } function R(e, r) { return e ? O(U, e, r) : "" } function M(e, r, t, n) {
      if (!(n > 0)) return 0; for (var o = t, i = t + n - 1, a = 0; a < e.length; ++a) {
        let s = e.charCodeAt(a); if (s >= 55296 && s <= 57343)s = 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++a); if (s <= 127) { if (t >= i) break; r[t++] = s }
        else if (s <= 2047) { if (t + 1 >= i) break; r[t++] = 192 | s >> 6, r[t++] = 128 | 63 & s }
        else if (s <= 65535) { if (t + 2 >= i) break; r[t++] = 224 | s >> 12, r[t++] = 128 | s >> 6 & 63, r[t++] = 128 | 63 & s }
        else { if (t + 3 >= i) break; s > 1114111 && T(`Invalid Unicode code point 0x${s.toString(16)} encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).`), r[t++] = 240 | s >> 18, r[t++] = 128 | s >> 12 & 63, r[t++] = 128 | s >> 6 & 63, r[t++] = 128 | 63 & s }
      } return r[t] = 0, t - o
    } function N(e, r, t) { return F(typeof t == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), M(e, U, r, t) } function I(e) { for (var r = 0, t = 0; t < e.length; ++t) { let n = e.charCodeAt(t); n >= 55296 && n <= 57343 && (n = 65536 + ((1023 & n) << 10) | 1023 & e.charCodeAt(++t)), n <= 127 ? ++r : r += n <= 2047 ? 2 : n <= 65535 ? 3 : 4 } return r } let L; let x; let U; let B; let j; let $; let W; let z; let H; const G = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0; function V(e, r) { F(e % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!"); for (var t = e, n = t >> 1, o = n + r / 2; !(n >= o) && j[n];)++n; if ((t = n << 1) - e > 32 && G) return G.decode(U.subarray(e, t)); for (var i = "", a = 0; !(a >= r / 2); ++a) { const s = B[e + 2 * a >> 1]; if (s == 0) break; i += String.fromCharCode(s) } return i } function Y(e, r, t) { if (F(r % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!"), F(typeof t == "number", "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), void 0 === t && (t = 2147483647), t < 2) return 0; for (var n = r, o = (t -= 2) < 2 * e.length ? t / 2 : e.length, i = 0; i < o; ++i) { const a = e.charCodeAt(i); B[r >> 1] = a, r += 2 } return B[r >> 1] = 0, r - n } function q(e) { return 2 * e.length } function X(e, r) {
      F(e % 4 == 0, "Pointer passed to UTF32ToString must be aligned to four bytes!"); for (var t = 0, n = ""; !(t >= r / 4);) {
        const o = $[e + 4 * t >> 2]; if (o == 0) break; if (++t, o >= 65536) { const i = o - 65536; n += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i) }
        else {
          n += String.fromCharCode(o)
        }
      } return n
    } function K(e, r, t) { if (F(r % 4 == 0, "Pointer passed to stringToUTF32 must be aligned to four bytes!"), F(typeof t == "number", "stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), void 0 === t && (t = 2147483647), t < 4) return 0; for (var n = r, o = n + t - 4, i = 0; i < e.length; ++i) { let a = e.charCodeAt(i); if (a >= 55296 && a <= 57343)a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++i); if ($[r >> 2] = a, (r += 4) + 4 > o) break } return $[r >> 2] = 0, r - n } function J(e) { for (var r = 0, t = 0; t < e.length; ++t) { const n = e.charCodeAt(t); n >= 55296 && n <= 57343 && ++t, r += 4 } return r } function Q(e) { const r = I(e) + 1; const t = gt(r); return t && M(e, x, t, r), t } function Z(e) { L = e, r.HEAP8 = x = new Int8Array(e), r.HEAP16 = B = new Int16Array(e), r.HEAP32 = $ = new Int32Array(e), r.HEAPU8 = U = new Uint8Array(e), r.HEAPU16 = j = new Uint16Array(e), r.HEAPU32 = W = new Uint32Array(e), r.HEAPF32 = z = new Float32Array(e), r.HEAPF64 = H = new Float64Array(e) } const ee = 5242880; r.TOTAL_STACK && F(ee === r.TOTAL_STACK, "the stack size can no longer be determined at runtime"); let re; const te = r.INITIAL_MEMORY || 67108864; function ne() { const e = kt(); F((3 & e) == 0), $[e >> 2] = 34821223, $[e + 4 >> 2] = 2310721022, $[0] = 1668509029 } function oe() { if (!A) { const e = kt(); const r = W[e >> 2]; const t = W[e + 4 >> 2]; r == 34821223 && t == 2310721022 || ge(`Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x${t.toString(16)} 0x${r.toString(16)}`), $[0] !== 1668509029 && ge("Runtime error: The application has corrupted its heap memory area (address zero)!") } }k("INITIAL_MEMORY", "INITIAL_MEMORY"), F(te >= ee, `INITIAL_MEMORY should be larger than TOTAL_STACK, was ${te}! (TOTAL_STACK=` + `5242880)`), F(typeof Int32Array != "undefined" && typeof Float64Array != "undefined" && Int32Array.prototype.subarray != null && Int32Array.prototype.set != null, "JS engine does not provide full typed array support"), F(!r.wasmMemory, "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"), F(te == 67108864, "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically"), (function () { const e = new Int16Array(1); const r = new Int8Array(e.buffer); if (e[0] = 25459, r[0] !== 115 || r[1] !== 99) throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)" }()); const ie = []; const ae = []; const se = []; let le = !1; F(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), F(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), F(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), F(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"); let ue = 0; let ce = null; let de = null; const fe = {}; function pe(e) { for (let r = e; ;) { if (!fe[e]) return e; e = r + Math.random() } } function me(e) { ue++, r.monitorRunDependencies && r.monitorRunDependencies(ue), e ? (F(!fe[e]), fe[e] = 1, ce === null && typeof setInterval != "undefined" && (ce = setInterval(() => { if (A) return clearInterval(ce), void (ce = null); let e = !1; for (const r in fe)e || (e = !0, _("still waiting on run dependencies:")), _(`dependency: ${r}`); e && _("(end of list)") }, 1e4))) : _("warning: run dependency added without ID") } function he(e) { if (ue--, r.monitorRunDependencies && r.monitorRunDependencies(ue), e ? (F(fe[e]), delete fe[e]) : _("warning: run dependency removed without ID"), ue == 0 && (ce !== null && (clearInterval(ce), ce = null), de)) { const t = de; de = null, t() } } function ge(e) { throw r.onAbort && r.onAbort(e), _(e = `Aborted(${e})`), A = !0, new WebAssembly.RuntimeError(e) } let ve, ye, Ee; function we(e) { return e.startsWith("data:application/octet-stream;base64,") } function be(e) { return e.startsWith("file://") } function _e(e, t) { return function () { const n = e; let o = t; return t || (o = r.asm), F(le, `native function \`${n}\` called before runtime initialization`), o[e] || F(o[e], `exported native function \`${n}\` not found`), o[e].apply(null, arguments) } } function Te(e) {
      try { if (e == ve && E) return new Uint8Array(E); if (p) return p(e); throw "both async and sync fetching of the wasm failed" }
      catch (e) { ge(e) }
    } function ke(e) {
      for (;e.length > 0;) {
        const t = e.shift(); if (typeof t != "function") { const n = t.func; typeof n == "number" ? void 0 === t.arg ? Ce(n)() : Ce(n)(t.arg) : n(void 0 === t.arg ? null : t.arg) }
        else {
          t(r)
        }
      }
    } function Se(e) { return e.replace(/\b_Z\w+/g, (e) => { let r; const t = (r = e, T("warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling"), r); return e === t ? e : `${t} [${e}]` }) } function Ce(e) { return re.get(e) } function Pe() {
      let e = new Error(); if (!e.stack) {
        try { throw new Error() }
        catch (r) { e = r } if (!e.stack) return "(no stack trace available)"
      } return e.stack.toString()
    }we(ve = "decoder.wasm") || (ve = (function (e) { return r.locateFile ? r.locateFile(e, v) : v + e }(ve))); var Ae = { isAbs: e => e.charAt(0) === "/", splitPath: e => /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?)?(\.[^./]*|))\/*$/.exec(e).slice(1), normalizeArray: (e, r) => {
      for (var t = 0, n = e.length - 1; n >= 0; n--) { const o = e[n]; o === "." ? e.splice(n, 1) : o === ".." ? (e.splice(n, 1), t++) : t && (e.splice(n, 1), t--) } if (r) {
        for (;t; t--)e.unshift("..");
      } return e
    }, normalize: (e) => { const r = Ae.isAbs(e); const t = e.substr(-1) === "/"; return (e = Ae.normalizeArray(e.split("/").filter(e => !!e), !r).join("/")) || r || (e = "."), e && t && (e += "/"), (r ? "/" : "") + e }, dirname: (e) => { const r = Ae.splitPath(e); const t = r[0]; let n = r[1]; return t || n ? (n && (n = n.substr(0, n.length - 1)), t + n) : "." }, basename: (e) => { if (e === "/") return "/"; const r = (e = (e = Ae.normalize(e)).replace(/\/$/, "")).lastIndexOf("/"); return r === -1 ? e : e.substr(r + 1) }, join() { const e = Array.prototype.slice.call(arguments, 0); return Ae.normalize(e.join("/")) }, join2: (e, r) => Ae.normalize(`${e}/${r}`) }; var Fe = { resolve() { for (var e = "", r = !1, t = arguments.length - 1; t >= -1 && !r; t--) { const n = t >= 0 ? arguments[t] : Ie.cwd(); if (typeof n != "string") throw new TypeError("Arguments to path.resolve must be strings"); if (!n) return ""; e = `${n}/${e}`, r = Ae.isAbs(n) } return (r ? "/" : "") + (e = Ae.normalizeArray(e.split("/").filter(e => !!e), !r).join("/")) || "." }, relative: (e, r) => {
      function t(e) { for (var r = 0; r < e.length && e[r] === ""; r++);for (var t = e.length - 1; t >= 0 && e[t] === ""; t--);return r > t ? [] : e.slice(r, t - r + 1) }e = Fe.resolve(e).substr(1), r = Fe.resolve(r).substr(1); for (var n = t(e.split("/")), o = t(r.split("/")), i = Math.min(n.length, o.length), a = i, s = 0; s < i; s++) {
        if (n[s] !== o[s]) { a = s; break }
      } let l = []; for (s = a; s < n.length; s++)l.push(".."); return (l = l.concat(o.slice(a))).join("/")
    } }; var De = { ttys: [], init() {}, shutdown() {}, register(e, r) { De.ttys[e] = { input: [], output: [], ops: r }, Ie.registerDevice(e, De.stream_ops) }, stream_ops: { open(e) { const r = De.ttys[e.node.rdev]; if (!r) throw new Ie.ErrnoError(43); e.tty = r, e.seekable = !1 }, close(e) { e.tty.ops.flush(e.tty) }, flush(e) { e.tty.ops.flush(e.tty) }, read(e, r, t, n, o) {
      if (!e.tty || !e.tty.ops.get_char) throw new Ie.ErrnoError(60); for (var i = 0, a = 0; a < n; a++) {
        var s; try { s = e.tty.ops.get_char(e.tty) }
        catch (e) { throw new Ie.ErrnoError(29) } if (void 0 === s && i === 0) throw new Ie.ErrnoError(6); if (s == null) break; i++, r[t + a] = s
      } return i && (e.node.timestamp = Date.now()), i
    }, write(e, r, t, n, o) {
      if (!e.tty || !e.tty.ops.put_char) throw new Ie.ErrnoError(60); try { for (var i = 0; i < n; i++)e.tty.ops.put_char(e.tty, r[t + i]) }
      catch (e) { throw new Ie.ErrnoError(29) } return n && (e.node.timestamp = Date.now()), i
    } }, default_tty_ops: { get_char(e) {
      if (!e.input.length) {
        let r = null; if (u) {
          const t = Buffer.alloc(256); let n = 0; try { n = m.readSync(process.stdin.fd, t, 0, 256, -1) }
          catch (e) { if (!e.toString().includes("EOF")) throw e; n = 0 }r = n > 0 ? t.slice(0, n).toString("utf-8") : null
        }
        else {
          typeof window != "undefined" && typeof window.prompt == "function" ? (r = window.prompt("Input: ")) !== null && (r += "\n") : typeof readline == "function" && (r = readline()) !== null && (r += "\n");
        } if (!r) return null; e.input = pt(r, !0)
      } return e.input.shift()
    }, put_char(e, r) { r === null || r === 10 ? (b(O(e.output, 0)), e.output = []) : r != 0 && e.output.push(r) }, flush(e) { e.output && e.output.length > 0 && (b(O(e.output, 0)), e.output = []) } }, default_tty1_ops: { put_char(e, r) { r === null || r === 10 ? (_(O(e.output, 0)), e.output = []) : r != 0 && e.output.push(r) }, flush(e) { e.output && e.output.length > 0 && (_(O(e.output, 0)), e.output = []) } } }; function Oe(e) { e = (function (e, r) { return F(r, "alignment argument is required"), Math.ceil(e / r) * r }(e, 65536)); const r = bt(65536, e); return r ? ((function (e, r) { U.fill(0, e, e + r) }(r, e)), r) : 0 } var Re = { ops_table: null, mount(e) { return Re.createNode(null, "/", 16895, 0) }, createNode(e, r, t, n) { if (Ie.isBlkdev(t) || Ie.isFIFO(t)) throw new Ie.ErrnoError(63); Re.ops_table || (Re.ops_table = { dir: { node: { getattr: Re.node_ops.getattr, setattr: Re.node_ops.setattr, lookup: Re.node_ops.lookup, mknod: Re.node_ops.mknod, rename: Re.node_ops.rename, unlink: Re.node_ops.unlink, rmdir: Re.node_ops.rmdir, readdir: Re.node_ops.readdir, symlink: Re.node_ops.symlink }, stream: { llseek: Re.stream_ops.llseek } }, file: { node: { getattr: Re.node_ops.getattr, setattr: Re.node_ops.setattr }, stream: { llseek: Re.stream_ops.llseek, read: Re.stream_ops.read, write: Re.stream_ops.write, allocate: Re.stream_ops.allocate, mmap: Re.stream_ops.mmap, msync: Re.stream_ops.msync } }, link: { node: { getattr: Re.node_ops.getattr, setattr: Re.node_ops.setattr, readlink: Re.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: Re.node_ops.getattr, setattr: Re.node_ops.setattr }, stream: Ie.chrdev_stream_ops } }); const o = Ie.createNode(e, r, t, n); return Ie.isDir(o.mode) ? (o.node_ops = Re.ops_table.dir.node, o.stream_ops = Re.ops_table.dir.stream, o.contents = {}) : Ie.isFile(o.mode) ? (o.node_ops = Re.ops_table.file.node, o.stream_ops = Re.ops_table.file.stream, o.usedBytes = 0, o.contents = null) : Ie.isLink(o.mode) ? (o.node_ops = Re.ops_table.link.node, o.stream_ops = Re.ops_table.link.stream) : Ie.isChrdev(o.mode) && (o.node_ops = Re.ops_table.chrdev.node, o.stream_ops = Re.ops_table.chrdev.stream), o.timestamp = Date.now(), e && (e.contents[r] = o, e.timestamp = o.timestamp), o }, getFileDataAsTypedArray(e) { return e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0) }, expandFileStorage(e, r) { const t = e.contents ? e.contents.length : 0; if (!(t >= r)) { r = Math.max(r, t * (t < 1048576 ? 2 : 1.125) >>> 0), t != 0 && (r = Math.max(r, 256)); const n = e.contents; e.contents = new Uint8Array(r), e.usedBytes > 0 && e.contents.set(n.subarray(0, e.usedBytes), 0) } }, resizeFileStorage(e, r) {
      if (e.usedBytes != r) {
        if (r == 0) {
          e.contents = null, e.usedBytes = 0;
        }
        else { const t = e.contents; e.contents = new Uint8Array(r), t && e.contents.set(t.subarray(0, Math.min(r, e.usedBytes))), e.usedBytes = r }
      }
    }, node_ops: { getattr(e) { const r = {}; return r.dev = Ie.isChrdev(e.mode) ? e.id : 1, r.ino = e.id, r.mode = e.mode, r.nlink = 1, r.uid = 0, r.gid = 0, r.rdev = e.rdev, Ie.isDir(e.mode) ? r.size = 4096 : Ie.isFile(e.mode) ? r.size = e.usedBytes : Ie.isLink(e.mode) ? r.size = e.link.length : r.size = 0, r.atime = new Date(e.timestamp), r.mtime = new Date(e.timestamp), r.ctime = new Date(e.timestamp), r.blksize = 4096, r.blocks = Math.ceil(r.size / r.blksize), r }, setattr(e, r) { void 0 !== r.mode && (e.mode = r.mode), void 0 !== r.timestamp && (e.timestamp = r.timestamp), void 0 !== r.size && Re.resizeFileStorage(e, r.size) }, lookup(e, r) { throw Ie.genericErrors[44] }, mknod(e, r, t, n) { return Re.createNode(e, r, t, n) }, rename(e, r, t) {
      if (Ie.isDir(e.mode)) {
        let n; try { n = Ie.lookupNode(r, t) }
        catch (e) {} if (n) {
          for (const o in n.contents) throw new Ie.ErrnoError(55)
        }
      } delete e.parent.contents[e.name], e.parent.timestamp = Date.now(), e.name = t, r.contents[t] = e, r.timestamp = e.parent.timestamp, e.parent = r
    }, unlink(e, r) { delete e.contents[r], e.timestamp = Date.now() }, rmdir(e, r) { const t = Ie.lookupNode(e, r); for (const n in t.contents) throw new Ie.ErrnoError(55); delete e.contents[r], e.timestamp = Date.now() }, readdir(e) { const r = [".", ".."]; for (const t in e.contents)e.contents.hasOwnProperty(t) && r.push(t); return r }, symlink(e, r, t) { const n = Re.createNode(e, r, 41471, 0); return n.link = t, n }, readlink(e) { if (!Ie.isLink(e.mode)) throw new Ie.ErrnoError(28); return e.link } }, stream_ops: { read(e, r, t, n, o) {
      const i = e.node.contents; if (o >= e.node.usedBytes) return 0; const a = Math.min(e.node.usedBytes - o, n); if (F(a >= 0), a > 8 && i.subarray) {
        r.set(i.subarray(o, o + a), t);
      }
      else {
        for (let s = 0; s < a; s++)r[t + s] = i[o + s];
      } return a
    }, write(e, r, t, n, o, i) {
      if (F(!(r instanceof ArrayBuffer)), r.buffer === x.buffer && (i = !1), !n) return 0; const a = e.node; if (a.timestamp = Date.now(), r.subarray && (!a.contents || a.contents.subarray)) { if (i) return F(o === 0, "canOwn must imply no weird position inside the file"), a.contents = r.subarray(t, t + n), a.usedBytes = n, n; if (a.usedBytes === 0 && o === 0) return a.contents = r.slice(t, t + n), a.usedBytes = n, n; if (o + n <= a.usedBytes) return a.contents.set(r.subarray(t, t + n), o), n } if (Re.expandFileStorage(a, o + n), a.contents.subarray && r.subarray) {
        a.contents.set(r.subarray(t, t + n), o);
      }
      else {
        for (let s = 0; s < n; s++)a.contents[o + s] = r[t + s];
      } return a.usedBytes = Math.max(a.usedBytes, o + n), n
    }, llseek(e, r, t) { let n = r; if (t === 1 ? n += e.position : t === 2 && Ie.isFile(e.node.mode) && (n += e.node.usedBytes), n < 0) throw new Ie.ErrnoError(28); return n }, allocate(e, r, t) { Re.expandFileStorage(e.node, r + t), e.node.usedBytes = Math.max(e.node.usedBytes, r + t) }, mmap(e, r, t, n, o, i) {
      if (r !== 0) throw new Ie.ErrnoError(28); if (!Ie.isFile(e.node.mode)) throw new Ie.ErrnoError(43); let a; let s; let l = e.node.contents; if (2 & i || l.buffer !== L) { if ((n > 0 || n + t < l.length) && (l = l.subarray ? l.subarray(n, n + t) : Array.prototype.slice.call(l, n, n + t)), s = !0, !(a = Oe(t))) throw new Ie.ErrnoError(48); x.set(l, a) }
      else {
        s = !1, a = l.byteOffset;
      } return { ptr: a, allocated: s }
    }, msync(e, r, t, n, o) { if (!Ie.isFile(e.node.mode)) throw new Ie.ErrnoError(43); return 2 & o || Re.stream_ops.write(e, r, 0, n, t, !1), 0 } } }; const Me = { 0: "Success", 1: "Arg list too long", 2: "Permission denied", 3: "Address already in use", 4: "Address not available", 5: "Address family not supported by protocol family", 6: "No more processes", 7: "Socket already connected", 8: "Bad file number", 9: "Trying to read unreadable message", 10: "Mount device busy", 11: "Operation canceled", 12: "No children", 13: "Connection aborted", 14: "Connection refused", 15: "Connection reset by peer", 16: "File locking deadlock error", 17: "Destination address required", 18: "Math arg out of domain of func", 19: "Quota exceeded", 20: "File exists", 21: "Bad address", 22: "File too large", 23: "Host is unreachable", 24: "Identifier removed", 25: "Illegal byte sequence", 26: "Connection already in progress", 27: "Interrupted system call", 28: "Invalid argument", 29: "I/O error", 30: "Socket is already connected", 31: "Is a directory", 32: "Too many symbolic links", 33: "Too many open files", 34: "Too many links", 35: "Message too long", 36: "Multihop attempted", 37: "File or path name too long", 38: "Network interface is not configured", 39: "Connection reset by network", 40: "Network is unreachable", 41: "Too many open files in system", 42: "No buffer space available", 43: "No such device", 44: "No such file or directory", 45: "Exec format error", 46: "No record locks available", 47: "The link has been severed", 48: "Not enough core", 49: "No message of desired type", 50: "Protocol not available", 51: "No space left on device", 52: "Function not implemented", 53: "Socket is not connected", 54: "Not a directory", 55: "Directory not empty", 56: "State not recoverable", 57: "Socket operation on non-socket", 59: "Not a typewriter", 60: "No such device or address", 61: "Value too large for defined data type", 62: "Previous owner died", 63: "Not super-user", 64: "Broken pipe", 65: "Protocol error", 66: "Unknown protocol", 67: "Protocol wrong type for socket", 68: "Math result not representable", 69: "Read only file system", 70: "Illegal seek", 71: "No such process", 72: "Stale file handle", 73: "Connection timed out", 74: "Text file busy", 75: "Cross-device link", 100: "Device not a stream", 101: "Bad font file fmt", 102: "Invalid slot", 103: "Invalid request code", 104: "No anode", 105: "Block device required", 106: "Channel number out of range", 107: "Level 3 halted", 108: "Level 3 reset", 109: "Link number out of range", 110: "Protocol driver not attached", 111: "No CSI structure available", 112: "Level 2 halted", 113: "Invalid exchange", 114: "Invalid request descriptor", 115: "Exchange full", 116: "No data (for no delay io)", 117: "Timer expired", 118: "Out of streams resources", 119: "Machine is not on the network", 120: "Package not installed", 121: "The object is remote", 122: "Advertise error", 123: "Srmount error", 124: "Communication error on send", 125: "Cross mount point (not really error)", 126: "Given log. name not unique", 127: "f.d. invalid for this operation", 128: "Remote address changed", 129: "Can   access a needed shared lib", 130: "Accessing a corrupted shared lib", 131: ".lib section in a.out corrupted", 132: "Attempting to link in too many libs", 133: "Attempting to exec a shared library", 135: "Streams pipe error", 136: "Too many users", 137: "Socket type not supported", 138: "Not supported", 139: "Protocol family not supported", 140: "Can't send after socket shutdown", 141: "Too many references", 142: "Host is down", 148: "No medium (in tape drive)", 156: "Level 2 not synchronized" }; let Ne = {}; var Ie = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: !1, ignorePermissions: !0, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath(e) {
      let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!(e = Fe.resolve(Ie.cwd(), e))) return { path: "", node: null }; const t = { follow_mount: !0, recurse_count: 0 }; if (r = Object.assign(t, r), r.recurse_count > 8) throw new Ie.ErrnoError(32); for (var n = Ae.normalizeArray(e.split("/").filter(e => !!e), !1), o = Ie.root, i = "/", a = 0; a < n.length; a++) {
        const s = a === n.length - 1; if (s && r.parent) break; if (o = Ie.lookupNode(o, n[a]), i = Ae.join2(i, n[a]), Ie.isMountpoint(o) && (!s || s && r.follow_mount) && (o = o.mounted.root), !s || r.follow) {
          for (let l = 0; Ie.isLink(o.mode);) { const u = Ie.readlink(i); i = Fe.resolve(Ae.dirname(i), u); const c = Ie.lookupPath(i, { recurse_count: r.recurse_count + 1 }); if (o = c.node, l++ > 40) throw new Ie.ErrnoError(32) }
        }
      } return { path: i, node: o }
    }, getPath: (e) => { for (var r; ;) { if (Ie.isRoot(e)) { const t = e.mount.mountpoint; return r ? t[t.length - 1] !== "/" ? `${t}/${r}` : t + r : t }r = r ? `${e.name}/${r}` : e.name, e = e.parent } }, hashName: (e, r) => { for (var t = 0, n = 0; n < r.length; n++)t = (t << 5) - t + r.charCodeAt(n) | 0; return (e + t >>> 0) % Ie.nameTable.length }, hashAddNode: (e) => { const r = Ie.hashName(e.parent.id, e.name); e.name_next = Ie.nameTable[r], Ie.nameTable[r] = e }, hashRemoveNode: (e) => {
      const r = Ie.hashName(e.parent.id, e.name); if (Ie.nameTable[r] === e) {
        Ie.nameTable[r] = e.name_next;
      }
      else {
        for (let t = Ie.nameTable[r]; t;) { if (t.name_next === e) { t.name_next = e.name_next; break }t = t.name_next }
      }
    }, lookupNode: (e, r) => { const t = Ie.mayLookup(e); if (t) throw new Ie.ErrnoError(t, e); for (let n = Ie.hashName(e.id, r), o = Ie.nameTable[n]; o; o = o.name_next) { const i = o.name; if (o.parent.id === e.id && i === r) return o } return Ie.lookup(e, r) }, createNode: (e, r, t, n) => { F(typeof e == "object"); const o = new Ie.FSNode(e, r, t, n); return Ie.hashAddNode(o), o }, destroyNode: (e) => { Ie.hashRemoveNode(e) }, isRoot: e => e === e.parent, isMountpoint: e => !!e.mounted, isFile: e => (61440 & e) == 32768, isDir: e => (61440 & e) == 16384, isLink: e => (61440 & e) == 40960, isChrdev: e => (61440 & e) == 8192, isBlkdev: e => (61440 & e) == 24576, isFIFO: e => (61440 & e) == 4096, isSocket: e => (49152 & e) == 49152, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: (e) => { const r = Ie.flagModes[e]; if (void 0 === r) throw new Error(`Unknown file open mode: ${e}`); return r }, flagsToPermissionString: (e) => { let r = ["r", "w", "rw"][3 & e]; return 512 & e && (r += "w"), r }, nodePermissions: (e, r) => Ie.ignorePermissions || (!r.includes("r") || 292 & e.mode) && (!r.includes("w") || 146 & e.mode) && (!r.includes("x") || 73 & e.mode) ? 0 : 2, mayLookup: (e) => { const r = Ie.nodePermissions(e, "x"); return r || (e.node_ops.lookup ? 0 : 2) }, mayCreate: (e, r) => {
      try { Ie.lookupNode(e, r); return 20 }
      catch (e) {} return Ie.nodePermissions(e, "wx")
    }, mayDelete: (e, r, t) => {
      let n; try { n = Ie.lookupNode(e, r) }
      catch (e) { return e.errno } const o = Ie.nodePermissions(e, "wx"); if (o) return o; if (t) { if (!Ie.isDir(n.mode)) return 54; if (Ie.isRoot(n) || Ie.getPath(n) === Ie.cwd()) return 10 }
      else if (Ie.isDir(n.mode)) {
        return 31;
      } return 0
    }, mayOpen: (e, r) => e ? Ie.isLink(e.mode) ? 32 : Ie.isDir(e.mode) && (Ie.flagsToPermissionString(r) !== "r" || 512 & r) ? 31 : Ie.nodePermissions(e, Ie.flagsToPermissionString(r)) : 44, MAX_OPEN_FDS: 4096, nextfd() {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ie.MAX_OPEN_FDS; for (let t = e; t <= r; t++) {
        if (!Ie.streams[t]) return t;
      } throw new Ie.ErrnoError(33)
    }, getStream: e => Ie.streams[e], createStream: (e, r, t) => { Ie.FSStream || (Ie.FSStream = function () { this.shared = {} }, Ie.FSStream.prototype = { object: { get() { return this.node }, set(e) { this.node = e } }, isRead: { get() { return (2097155 & this.flags) != 1 } }, isWrite: { get() { return (2097155 & this.flags) != 0 } }, isAppend: { get() { return 1024 & this.flags } }, flags: { get() { return this.shared.flags }, set(e) { this.shared.flags = e } }, position: { get function() { return this.shared.position }, set(e) { this.shared.position = e } } }), e = Object.assign(new Ie.FSStream(), e); const n = Ie.nextfd(r, t); return e.fd = n, Ie.streams[n] = e, e }, closeStream: (e) => { Ie.streams[e] = null }, chrdev_stream_ops: { open: (e) => { const r = Ie.getDevice(e.node.rdev); e.stream_ops = r.stream_ops, e.stream_ops.open && e.stream_ops.open(e) }, llseek: () => { throw new Ie.ErrnoError(70) } }, major: e => e >> 8, minor: e => 255 & e, makedev: (e, r) => e << 8 | r, registerDevice: (e, r) => { Ie.devices[e] = { stream_ops: r } }, getDevice: e => Ie.devices[e], getMounts: (e) => { for (var r = [], t = [e]; t.length;) { const n = t.pop(); r.push(n), t.push.apply(t, n.mounts) } return r }, syncfs: (e, r) => { typeof e == "function" && (r = e, e = !1), Ie.syncFSRequests++, Ie.syncFSRequests > 1 && _(`warning: ${Ie.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`); const t = Ie.getMounts(Ie.root.mount); let n = 0; function o(e) { return F(Ie.syncFSRequests > 0), Ie.syncFSRequests--, r(e) } function i(e) { if (e) return i.errored ? void 0 : (i.errored = !0, o(e)); ++n >= t.length && o(null) }t.forEach((r) => { if (!r.type.syncfs) return i(null); r.type.syncfs(r, e, i) }) }, mount: (e, r, t) => { if (typeof e == "string") throw e; let n; const o = t === "/"; const i = !t; if (o && Ie.root) throw new Ie.ErrnoError(10); if (!o && !i) { const a = Ie.lookupPath(t, { follow_mount: !1 }); if (t = a.path, n = a.node, Ie.isMountpoint(n)) throw new Ie.ErrnoError(10); if (!Ie.isDir(n.mode)) throw new Ie.ErrnoError(54) } const s = { type: e, opts: r, mountpoint: t, mounts: [] }; const l = e.mount(s); return l.mount = s, s.root = l, o ? Ie.root = l : n && (n.mounted = s, n.mount && n.mount.mounts.push(s)), l }, unmount: (e) => { const r = Ie.lookupPath(e, { follow_mount: !1 }); if (!Ie.isMountpoint(r.node)) throw new Ie.ErrnoError(28); const t = r.node; const n = t.mounted; const o = Ie.getMounts(n); Object.keys(Ie.nameTable).forEach((e) => { for (let r = Ie.nameTable[e]; r;) { const t = r.name_next; o.includes(r.mount) && Ie.destroyNode(r), r = t } }), t.mounted = null; const i = t.mount.mounts.indexOf(n); F(i !== -1), t.mount.mounts.splice(i, 1) }, lookup: (e, r) => e.node_ops.lookup(e, r), mknod: (e, r, t) => { const n = Ie.lookupPath(e, { parent: !0 }).node; const o = Ae.basename(e); if (!o || o === "." || o === "..") throw new Ie.ErrnoError(28); const i = Ie.mayCreate(n, o); if (i) throw new Ie.ErrnoError(i); if (!n.node_ops.mknod) throw new Ie.ErrnoError(63); return n.node_ops.mknod(n, o, r, t) }, create: (e, r) => (r = void 0 !== r ? r : 438, r &= 4095, r |= 32768, Ie.mknod(e, r, 0)), mkdir: (e, r) => (r = void 0 !== r ? r : 511, r &= 1023, r |= 16384, Ie.mknod(e, r, 0)), mkdirTree: (e, r) => {
      for (let t = e.split("/"), n = "", o = 0; o < t.length; ++o) {
        if (t[o]) {
          n += `/${t[o]}`; try { Ie.mkdir(n, r) }
          catch (e) { if (e.errno != 20) throw e }
        }
      }
    }, mkdev: (e, r, t) => (void 0 === t && (t = r, r = 438), r |= 8192, Ie.mknod(e, r, t)), symlink: (e, r) => { if (!Fe.resolve(e)) throw new Ie.ErrnoError(44); const t = Ie.lookupPath(r, { parent: !0 }).node; if (!t) throw new Ie.ErrnoError(44); const n = Ae.basename(r); const o = Ie.mayCreate(t, n); if (o) throw new Ie.ErrnoError(o); if (!t.node_ops.symlink) throw new Ie.ErrnoError(63); return t.node_ops.symlink(t, n, e) }, rename: (e, r) => {
      let t; let n; const o = Ae.dirname(e); const i = Ae.dirname(r); const a = Ae.basename(e); const s = Ae.basename(r); if (t = Ie.lookupPath(e, { parent: !0 }).node, n = Ie.lookupPath(r, { parent: !0 }).node, !t || !n) throw new Ie.ErrnoError(44); if (t.mount !== n.mount) throw new Ie.ErrnoError(75); let l; const u = Ie.lookupNode(t, a); let c = Fe.relative(e, i); if (c.charAt(0) !== ".") throw new Ie.ErrnoError(28); if ((c = Fe.relative(r, o)).charAt(0) !== ".") throw new Ie.ErrnoError(55); try { l = Ie.lookupNode(n, s) }
      catch (e) {} if (u !== l) {
        const d = Ie.isDir(u.mode); let f = Ie.mayDelete(t, a, d); if (f) throw new Ie.ErrnoError(f); if (f = l ? Ie.mayDelete(n, s, d) : Ie.mayCreate(n, s)) throw new Ie.ErrnoError(f); if (!t.node_ops.rename) throw new Ie.ErrnoError(63); if (Ie.isMountpoint(u) || l && Ie.isMountpoint(l)) throw new Ie.ErrnoError(10); if (n !== t && (f = Ie.nodePermissions(t, "w"))) throw new Ie.ErrnoError(f); Ie.hashRemoveNode(u); try { t.node_ops.rename(u, n, s) }
        catch (e) { throw e }
        finally { Ie.hashAddNode(u) }
      }
    }, rmdir: (e) => { const r = Ie.lookupPath(e, { parent: !0 }).node; const t = Ae.basename(e); const n = Ie.lookupNode(r, t); const o = Ie.mayDelete(r, t, !0); if (o) throw new Ie.ErrnoError(o); if (!r.node_ops.rmdir) throw new Ie.ErrnoError(63); if (Ie.isMountpoint(n)) throw new Ie.ErrnoError(10); r.node_ops.rmdir(r, t), Ie.destroyNode(n) }, readdir: (e) => { const r = Ie.lookupPath(e, { follow: !0 }).node; if (!r.node_ops.readdir) throw new Ie.ErrnoError(54); return r.node_ops.readdir(r) }, unlink: (e) => { const r = Ie.lookupPath(e, { parent: !0 }).node; if (!r) throw new Ie.ErrnoError(44); const t = Ae.basename(e); const n = Ie.lookupNode(r, t); const o = Ie.mayDelete(r, t, !1); if (o) throw new Ie.ErrnoError(o); if (!r.node_ops.unlink) throw new Ie.ErrnoError(63); if (Ie.isMountpoint(n)) throw new Ie.ErrnoError(10); r.node_ops.unlink(r, t), Ie.destroyNode(n) }, readlink: (e) => { const r = Ie.lookupPath(e).node; if (!r) throw new Ie.ErrnoError(44); if (!r.node_ops.readlink) throw new Ie.ErrnoError(28); return Fe.resolve(Ie.getPath(r.parent), r.node_ops.readlink(r)) }, stat: (e, r) => { const t = Ie.lookupPath(e, { follow: !r }).node; if (!t) throw new Ie.ErrnoError(44); if (!t.node_ops.getattr) throw new Ie.ErrnoError(63); return t.node_ops.getattr(t) }, lstat: e => Ie.stat(e, !0), chmod: (e, r, t) => { let n; typeof e == "string" ? n = Ie.lookupPath(e, { follow: !t }).node : n = e; if (!n.node_ops.setattr) throw new Ie.ErrnoError(63); n.node_ops.setattr(n, { mode: 4095 & r | -4096 & n.mode, timestamp: Date.now() }) }, lchmod: (e, r) => { Ie.chmod(e, r, !0) }, fchmod: (e, r) => { const t = Ie.getStream(e); if (!t) throw new Ie.ErrnoError(8); Ie.chmod(t.node, r) }, chown: (e, r, t, n) => { let o; typeof e == "string" ? o = Ie.lookupPath(e, { follow: !n }).node : o = e; if (!o.node_ops.setattr) throw new Ie.ErrnoError(63); o.node_ops.setattr(o, { timestamp: Date.now() }) }, lchown: (e, r, t) => { Ie.chown(e, r, t, !0) }, fchown: (e, r, t) => { const n = Ie.getStream(e); if (!n) throw new Ie.ErrnoError(8); Ie.chown(n.node, r, t) }, truncate: (e, r) => { if (r < 0) throw new Ie.ErrnoError(28); let t; typeof e == "string" ? t = Ie.lookupPath(e, { follow: !0 }).node : t = e; if (!t.node_ops.setattr) throw new Ie.ErrnoError(63); if (Ie.isDir(t.mode)) throw new Ie.ErrnoError(31); if (!Ie.isFile(t.mode)) throw new Ie.ErrnoError(28); const n = Ie.nodePermissions(t, "w"); if (n) throw new Ie.ErrnoError(n); t.node_ops.setattr(t, { size: r, timestamp: Date.now() }) }, ftruncate: (e, r) => { const t = Ie.getStream(e); if (!t) throw new Ie.ErrnoError(8); if ((2097155 & t.flags) == 0) throw new Ie.ErrnoError(28); Ie.truncate(t.node, r) }, utime: (e, r, t) => { const n = Ie.lookupPath(e, { follow: !0 }).node; n.node_ops.setattr(n, { timestamp: Math.max(r, t) }) }, open: (e, t, n, o, i) => {
      if (e === "") throw new Ie.ErrnoError(44); let a; if (n = void 0 === n ? 438 : n, n = 64 & (t = typeof t == "string" ? Ie.modeStringToFlags(t) : t) ? 4095 & n | 32768 : 0, typeof e == "object") {
        a = e;
      }
      else {
        e = Ae.normalize(e); try { a = Ie.lookupPath(e, { follow: !(131072 & t) }).node }
        catch (e) {}
      } let s = !1; if (64 & t) {
        if (a) { if (128 & t) throw new Ie.ErrnoError(20) }
        else {
          a = Ie.mknod(e, n, 0), s = !0;
        }
      } if (!a) throw new Ie.ErrnoError(44); if (Ie.isChrdev(a.mode) && (t &= -513), 65536 & t && !Ie.isDir(a.mode)) throw new Ie.ErrnoError(54); if (!s) { const l = Ie.mayOpen(a, t); if (l) throw new Ie.ErrnoError(l) }512 & t && Ie.truncate(a, 0), t &= -131713; const u = Ie.createStream({ node: a, path: Ie.getPath(a), flags: t, seekable: !0, position: 0, stream_ops: a.stream_ops, ungotten: [], error: !1 }, o, i); return u.stream_ops.open && u.stream_ops.open(u), !r.logReadFiles || 1 & t || (Ie.readFiles || (Ie.readFiles = {}), e in Ie.readFiles || (Ie.readFiles[e] = 1)), u
    }, close: (e) => {
      if (Ie.isClosed(e)) throw new Ie.ErrnoError(8); e.getdents && (e.getdents = null); try { e.stream_ops.close && e.stream_ops.close(e) }
      catch (e) { throw e }
      finally { Ie.closeStream(e.fd) }e.fd = null
    }, isClosed: e => e.fd === null, llseek: (e, r, t) => { if (Ie.isClosed(e)) throw new Ie.ErrnoError(8); if (!e.seekable || !e.stream_ops.llseek) throw new Ie.ErrnoError(70); if (t != 0 && t != 1 && t != 2) throw new Ie.ErrnoError(28); return e.position = e.stream_ops.llseek(e, r, t), e.ungotten = [], e.position }, read: (e, r, t, n, o) => {
      if (n < 0 || o < 0) throw new Ie.ErrnoError(28); if (Ie.isClosed(e)) throw new Ie.ErrnoError(8); if ((2097155 & e.flags) == 1) throw new Ie.ErrnoError(8); if (Ie.isDir(e.node.mode)) throw new Ie.ErrnoError(31); if (!e.stream_ops.read) throw new Ie.ErrnoError(28); const i = void 0 !== o; if (i) { if (!e.seekable) throw new Ie.ErrnoError(70) }
      else {
        o = e.position;
      } const a = e.stream_ops.read(e, r, t, n, o); return i || (e.position += a), a
    }, write: (e, r, t, n, o, i) => {
      if (n < 0 || o < 0) throw new Ie.ErrnoError(28); if (Ie.isClosed(e)) throw new Ie.ErrnoError(8); if ((2097155 & e.flags) == 0) throw new Ie.ErrnoError(8); if (Ie.isDir(e.node.mode)) throw new Ie.ErrnoError(31); if (!e.stream_ops.write) throw new Ie.ErrnoError(28); e.seekable && 1024 & e.flags && Ie.llseek(e, 0, 2); const a = void 0 !== o; if (a) { if (!e.seekable) throw new Ie.ErrnoError(70) }
      else {
        o = e.position;
      } const s = e.stream_ops.write(e, r, t, n, o, i); return a || (e.position += s), s
    }, allocate: (e, r, t) => { if (Ie.isClosed(e)) throw new Ie.ErrnoError(8); if (r < 0 || t <= 0) throw new Ie.ErrnoError(28); if ((2097155 & e.flags) == 0) throw new Ie.ErrnoError(8); if (!Ie.isFile(e.node.mode) && !Ie.isDir(e.node.mode)) throw new Ie.ErrnoError(43); if (!e.stream_ops.allocate) throw new Ie.ErrnoError(138); e.stream_ops.allocate(e, r, t) }, mmap: (e, r, t, n, o, i) => { if ((2 & o) != 0 && (2 & i) == 0 && (2097155 & e.flags) != 2) throw new Ie.ErrnoError(2); if ((2097155 & e.flags) == 1) throw new Ie.ErrnoError(2); if (!e.stream_ops.mmap) throw new Ie.ErrnoError(43); return e.stream_ops.mmap(e, r, t, n, o, i) }, msync: (e, r, t, n, o) => e && e.stream_ops.msync ? e.stream_ops.msync(e, r, t, n, o) : 0, munmap: e => 0, ioctl: (e, r, t) => { if (!e.stream_ops.ioctl) throw new Ie.ErrnoError(59); return e.stream_ops.ioctl(e, r, t) }, readFile(e) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (r.flags = r.flags || 0, r.encoding = r.encoding || "binary", r.encoding !== "utf8" && r.encoding !== "binary") throw new Error(`Invalid encoding type "${r.encoding}"`); let t; const n = Ie.open(e, r.flags); const o = Ie.stat(e); const i = o.size; const a = new Uint8Array(i); return Ie.read(n, a, 0, i, 0), r.encoding === "utf8" ? t = O(a, 0) : r.encoding === "binary" && (t = a), Ie.close(n), t }, writeFile(e, r) {
      const t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; t.flags = t.flags || 577; const n = Ie.open(e, t.flags, t.mode); if (typeof r == "string") { const o = new Uint8Array(I(r) + 1); const i = M(r, o, 0, o.length); Ie.write(n, o, 0, i, void 0, t.canOwn) }
      else { if (!ArrayBuffer.isView(r)) throw new Error("Unsupported data type"); Ie.write(n, r, 0, r.byteLength, void 0, t.canOwn) }Ie.close(n)
    }, cwd: () => Ie.currentPath, chdir: (e) => { const r = Ie.lookupPath(e, { follow: !0 }); if (r.node === null) throw new Ie.ErrnoError(44); if (!Ie.isDir(r.node.mode)) throw new Ie.ErrnoError(54); const t = Ie.nodePermissions(r.node, "x"); if (t) throw new Ie.ErrnoError(t); Ie.currentPath = r.path }, createDefaultDirectories: () => { Ie.mkdir("/tmp"), Ie.mkdir("/home"), Ie.mkdir("/home/web_user") }, createDefaultDevices: () => {
      Ie.mkdir("/dev"), Ie.registerDevice(Ie.makedev(1, 3), { read: () => 0, write: (e, r, t, n, o) => n }), Ie.mkdev("/dev/null", Ie.makedev(1, 3)), De.register(Ie.makedev(5, 0), De.default_tty_ops), De.register(Ie.makedev(6, 0), De.default_tty1_ops), Ie.mkdev("/dev/tty", Ie.makedev(5, 0)), Ie.mkdev("/dev/tty1", Ie.makedev(6, 0)); const e = (function () {
        if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") { const e = new Uint8Array(1); return function () { return crypto.getRandomValues(e), e[0] } } if (u) {
          try { const r = a.default; return function () { return r.randomBytes(1)[0] } }
          catch (e) {}
        } return function () { ge("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };") }
      }()); Ie.createDevice("/dev", "random", e), Ie.createDevice("/dev", "urandom", e), Ie.mkdir("/dev/shm"), Ie.mkdir("/dev/shm/tmp")
    }, createSpecialDirectories: () => { Ie.mkdir("/proc"); const e = Ie.mkdir("/proc/self"); Ie.mkdir("/proc/self/fd"), Ie.mount({ mount: () => { const r = Ie.createNode(e, "fd", 16895, 73); return r.node_ops = { lookup: (e, r) => { const t = +r; const n = Ie.getStream(t); if (!n) throw new Ie.ErrnoError(8); const o = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => n.path } }; return o.parent = o, o } }, r } }, {}, "/proc/self/fd") }, createStandardStreams: () => { r.stdin ? Ie.createDevice("/dev", "stdin", r.stdin) : Ie.symlink("/dev/tty", "/dev/stdin"), r.stdout ? Ie.createDevice("/dev", "stdout", null, r.stdout) : Ie.symlink("/dev/tty", "/dev/stdout"), r.stderr ? Ie.createDevice("/dev", "stderr", null, r.stderr) : Ie.symlink("/dev/tty1", "/dev/stderr"); const e = Ie.open("/dev/stdin", 0); const t = Ie.open("/dev/stdout", 1); const n = Ie.open("/dev/stderr", 1); F(e.fd === 0, `invalid handle for stdin (${e.fd})`), F(t.fd === 1, `invalid handle for stdout (${t.fd})`), F(n.fd === 2, `invalid handle for stderr (${n.fd})`) }, ensureErrnoError: () => {
      Ie.ErrnoError || (Ie.ErrnoError = function (e, r) {
        this.node = r, this.setErrno = function (e) {
          for (const r in this.errno = e, Ne) {
            if (Ne[r] === e) { this.code = r; break }
          }
        }, this.setErrno(e), this.message = Me[e], this.stack && (Object.defineProperty(this, "stack", { value: (new Error()).stack, writable: !0 }), this.stack = Se(this.stack))
      }, Ie.ErrnoError.prototype = new Error(), Ie.ErrnoError.prototype.constructor = Ie.ErrnoError, [44].forEach((e) => { Ie.genericErrors[e] = new Ie.ErrnoError(e), Ie.genericErrors[e].stack = "<generic error, no stack>" }))
    }, staticInit: () => { Ie.ensureErrnoError(), Ie.nameTable = Array.from({ length: 4096 }), Ie.mount(Re, {}, "/"), Ie.createDefaultDirectories(), Ie.createDefaultDevices(), Ie.createSpecialDirectories(), Ie.filesystems = { MEMFS: Re } }, init: (e, t, n) => { F(!Ie.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"), Ie.init.initialized = !0, Ie.ensureErrnoError(), r.stdin = e || r.stdin, r.stdout = t || r.stdout, r.stderr = n || r.stderr, Ie.createStandardStreams() }, quit: () => { Ie.init.initialized = !1, wt(); for (let e = 0; e < Ie.streams.length; e++) { const r = Ie.streams[e]; r && Ie.close(r) } }, getMode: (e, r) => { let t = 0; return e && (t |= 365), r && (t |= 146), t }, findObject: (e, r) => { const t = Ie.analyzePath(e, r); return t.exists ? t.object : null }, analyzePath: (e, r) => {
      try { e = (n = Ie.lookupPath(e, { follow: !r })).path }
      catch (e) {} const t = { isRoot: !1, exists: !1, error: 0, name: null, path: null, object: null, parentExists: !1, parentPath: null, parentObject: null }; try { var n = Ie.lookupPath(e, { parent: !0 }); t.parentExists = !0, t.parentPath = n.path, t.parentObject = n.node, t.name = Ae.basename(e), n = Ie.lookupPath(e, { follow: !r }), t.exists = !0, t.path = n.path, t.object = n.node, t.name = n.node.name, t.isRoot = n.path === "/" }
      catch (e) { t.error = e.errno } return t
    }, createPath: (e, r, t, n) => {
      e = typeof e == "string" ? e : Ie.getPath(e); for (let o = r.split("/").reverse(); o.length;) {
        const i = o.pop(); if (i) {
          var a = Ae.join2(e, i); try { Ie.mkdir(a) }
          catch (e) {}e = a
        }
      } return a
    }, createFile: (e, r, t, n, o) => { const i = Ae.join2(typeof e == "string" ? e : Ie.getPath(e), r); const a = Ie.getMode(n, o); return Ie.create(i, a) }, createDataFile: (e, r, t, n, o, i) => { let a = r; e && (e = typeof e == "string" ? e : Ie.getPath(e), a = r ? Ae.join2(e, r) : e); const s = Ie.getMode(n, o); const l = Ie.create(a, s); if (t) { if (typeof t == "string") { for (var u = Array.from({ length: t.length }), c = 0, d = t.length; c < d; ++c)u[c] = t.charCodeAt(c); t = u }Ie.chmod(l, 146 | s); const f = Ie.open(l, 577); Ie.write(f, t, 0, t.length, 0, i), Ie.close(f), Ie.chmod(l, s) } return l }, createDevice: (e, r, t, n) => {
      const o = Ae.join2(typeof e == "string" ? e : Ie.getPath(e), r); const i = Ie.getMode(!!t, !!n); Ie.createDevice.major || (Ie.createDevice.major = 64); const a = Ie.makedev(Ie.createDevice.major++, 0); return Ie.registerDevice(a, { open: (e) => { e.seekable = !1 }, close: (e) => { n && n.buffer && n.buffer.length && n(10) }, read: (e, r, n, o, i) => {
        for (var a = 0, s = 0; s < o; s++) {
          var l; try { l = t() }
          catch (e) { throw new Ie.ErrnoError(29) } if (void 0 === l && a === 0) throw new Ie.ErrnoError(6); if (l == null) break; a++, r[n + s] = l
        } return a && (e.node.timestamp = Date.now()), a
      }, write: (e, r, t, o, i) => {
        for (var a = 0; a < o; a++) {
          try { n(r[t + a]) }
          catch (e) { throw new Ie.ErrnoError(29) }
        } return o && (e.node.timestamp = Date.now()), a
      } }), Ie.mkdev(o, i, a)
    }, forceLoadFile: (e) => {
      if (e.isDevice || e.isFolder || e.link || e.contents) return !0; if (typeof XMLHttpRequest != "undefined") throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."); if (!d) throw new Error("Cannot load without read() or XMLHttpRequest."); try { e.contents = pt(d(e.url), !0), e.usedBytes = e.contents.length }
      catch (e) { throw new Ie.ErrnoError(29) }
    }, createLazyFile: (e, r, t, n, o) => {
      function i() { this.lengthKnown = !1, this.chunks = [] } if (i.prototype.get = function (e) { if (!(e > this.length - 1 || e < 0)) { const r = e % this.chunkSize; const t = e / this.chunkSize | 0; return this.getter(t)[r] } }, i.prototype.setDataGetter = function (e) { this.getter = e }, i.prototype.cacheLength = function () { const e = new XMLHttpRequest(); if (e.open("HEAD", t, !1), e.send(null), !(e.status >= 200 && e.status < 300 || e.status === 304)) throw new Error(`Couldn't load ${t}. Status: ${e.status}`); let r; let n = Number(e.getResponseHeader("Content-length")); const o = (r = e.getResponseHeader("Accept-Ranges")) && r === "bytes"; const i = (r = e.getResponseHeader("Content-Encoding")) && r === "gzip"; let a = 1048576; o || (a = n); const s = this; s.setDataGetter((e) => { const r = e * a; let o = (e + 1) * a - 1; if (o = Math.min(o, n - 1), void 0 === s.chunks[e] && (s.chunks[e] = ((e, r) => { if (e > r) throw new Error(`invalid range (${e}, ${r}) or no bytes requested!`); if (r > n - 1) throw new Error(`only ${n} bytes available! programmer error!`); const o = new XMLHttpRequest(); if (o.open("GET", t, !1), n !== a && o.setRequestHeader("Range", `bytes=${e}-${r}`), o.responseType = "arraybuffer", o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.send(null), !(o.status >= 200 && o.status < 300 || o.status === 304)) throw new Error(`Couldn't load ${t}. Status: ${o.status}`); return void 0 !== o.response ? new Uint8Array(o.response || []) : pt(o.responseText || "", !0) })(r, o)), void 0 === s.chunks[e]) throw new Error("doXHR failed!"); return s.chunks[e] }), !i && n || (a = n = 1, n = this.getter(0).length, a = n, b("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = n, this._chunkSize = a, this.lengthKnown = !0 }, typeof XMLHttpRequest != "undefined") { if (!l) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; const a = new i(); Object.defineProperties(a, { length: { get() { return this.lengthKnown || this.cacheLength(), this._length } }, chunkSize: { get() { return this.lengthKnown || this.cacheLength(), this._chunkSize } } }); var s = { isDevice: !1, contents: a } }
      else {
        s = { isDevice: !1, url: t };
      } const u = Ie.createFile(e, r, s, n, o); s.contents ? u.contents = s.contents : s.url && (u.contents = null, u.url = s.url), Object.defineProperties(u, { usedBytes: { get() { return this.contents.length } } }); const c = {}; return Object.keys(u.stream_ops).forEach((e) => { const r = u.stream_ops[e]; c[e] = function () { return Ie.forceLoadFile(u), r.apply(null, arguments) } }), c.read = (e, r, t, n, o) => {
        Ie.forceLoadFile(u); const i = e.node.contents; if (o >= i.length) return 0; const a = Math.min(i.length - o, n); if (F(a >= 0), i.slice) {
          for (var s = 0; s < a; s++)r[t + s] = i[o + s];
        }
        else {
          for (s = 0; s < a; s++)r[t + s] = i.get(o + s);
        } return a
      }, u.stream_ops = c, u
    }, createPreloadedFile: (e, r, t, n, o, i, a, s, l, u) => { const c = r ? Fe.resolve(Ae.join2(e, r)) : e; const d = pe(`cp ${c}`); function p(t) { function f(t) { u && u(), s || Ie.createDataFile(e, r, t, n, o, l), i && i(), he(d) }Browser.handledByPreloadPlugin(t, c, f, () => { a && a(), he(d) }) || f(t) }me(d), typeof t == "string" ? (function (e, r, t, n) { const o = n ? "" : pe(`al ${e}`); f(e, (t) => { F(t, `Loading data file "${e}" failed (no arrayBuffer).`), r(new Uint8Array(t)), o && he(o) }, (r) => { if (!t) throw `Loading data file "${e}" failed.`; t() }), o && me(o) }(t, e => p(e), a)) : p(t) }, indexedDB: () => window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB, DB_NAME: () => `EM_FS_${window.location.pathname}`, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: (e, r, t) => {
      r = r || (() => {}), t = t || (() => {}); const n = Ie.indexedDB(); try { var o = n.open(Ie.DB_NAME(), Ie.DB_VERSION) }
      catch (e) { return t(e) }o.onupgradeneeded = () => { b("creating db"), o.result.createObjectStore(Ie.DB_STORE_NAME) }, o.onsuccess = () => { const n = o.result.transaction([Ie.DB_STORE_NAME], "readwrite"); const i = n.objectStore(Ie.DB_STORE_NAME); let a = 0; let s = 0; const l = e.length; function u() { s == 0 ? r() : t() }e.forEach((e) => { const r = i.put(Ie.analyzePath(e).object.contents, e); r.onsuccess = () => { ++a + s == l && u() }, r.onerror = () => { s++, a + s == l && u() } }), n.onerror = t }, o.onerror = t
    }, loadFilesFromDB: (e, r, t) => {
      r = r || (() => {}), t = t || (() => {}); const n = Ie.indexedDB(); try { var o = n.open(Ie.DB_NAME(), Ie.DB_VERSION) }
      catch (e) { return t(e) }o.onupgradeneeded = t, o.onsuccess = () => {
        const n = o.result; try { var i = n.transaction([Ie.DB_STORE_NAME], "readonly") }
        catch (e) { return void t(e) } const a = i.objectStore(Ie.DB_STORE_NAME); let s = 0; let l = 0; const u = e.length; function c() { l == 0 ? r() : t() }e.forEach((e) => { const r = a.get(e); r.onsuccess = () => { Ie.analyzePath(e).exists && Ie.unlink(e), Ie.createDataFile(Ae.dirname(e), Ae.basename(e), r.result, !0, !0, !0), ++s + l == u && c() }, r.onerror = () => { l++, s + l == u && c() } }), i.onerror = t
      }, o.onerror = t
    }, absolutePath: () => { ge("FS.absolutePath has been removed; use PATH_FS.resolve instead") }, createFolder: () => { ge("FS.createFolder has been removed; use FS.mkdir instead") }, createLink: () => { ge("FS.createLink has been removed; use FS.symlink instead") }, joinPath: () => { ge("FS.joinPath has been removed; use PATH.join instead") }, mmapAlloc: () => { ge("FS.mmapAlloc has been replaced by the top level function mmapAlloc") }, standardizePath: () => { ge("FS.standardizePath has been removed; use PATH.normalize instead") } }; var Le = { DEFAULT_POLLMASK: 5, calculateAt(e, r, t) {
      if (Ae.isAbs(r)) return r; let n; if (e === -100) {
        n = Ie.cwd();
      }
      else { const o = Ie.getStream(e); if (!o) throw new Ie.ErrnoError(8); n = o.path } if (r.length == 0) { if (!t) throw new Ie.ErrnoError(44); return n } return Ae.join2(n, r)
    }, doStat(e, r, t) {
      try { var n = e(r) }
      catch (e) { if (e && e.node && Ae.normalize(r) !== Ae.normalize(Ie.getPath(e.node))) return -54; throw e } return $[t >> 2] = n.dev, $[t + 4 >> 2] = 0, $[t + 8 >> 2] = n.ino, $[t + 12 >> 2] = n.mode, $[t + 16 >> 2] = n.nlink, $[t + 20 >> 2] = n.uid, $[t + 24 >> 2] = n.gid, $[t + 28 >> 2] = n.rdev, $[t + 32 >> 2] = 0, Ee = [n.size >>> 0, (ye = n.size, +Math.abs(ye) >= 1 ? ye > 0 ? (0 | Math.min(+Math.floor(ye / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ye - +(~~ye >>> 0)) / 4294967296) >>> 0 : 0)], $[t + 40 >> 2] = Ee[0], $[t + 44 >> 2] = Ee[1], $[t + 48 >> 2] = 4096, $[t + 52 >> 2] = n.blocks, $[t + 56 >> 2] = n.atime.getTime() / 1e3 | 0, $[t + 60 >> 2] = 0, $[t + 64 >> 2] = n.mtime.getTime() / 1e3 | 0, $[t + 68 >> 2] = 0, $[t + 72 >> 2] = n.ctime.getTime() / 1e3 | 0, $[t + 76 >> 2] = 0, Ee = [n.ino >>> 0, (ye = n.ino, +Math.abs(ye) >= 1 ? ye > 0 ? (0 | Math.min(+Math.floor(ye / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ye - +(~~ye >>> 0)) / 4294967296) >>> 0 : 0)], $[t + 80 >> 2] = Ee[0], $[t + 84 >> 2] = Ee[1], 0
    }, doMsync(e, r, t, n, o) { const i = U.slice(e, e + t); Ie.msync(r, i, o, t, n) }, doMknod(e, r, t) { switch (61440 & r) { case 32768:case 8192:case 24576:case 4096:case 49152:break; default:return -28 } return Ie.mknod(e, r, t), 0 }, doReadlink(e, r, t) { if (t <= 0) return -28; const n = Ie.readlink(e); const o = Math.min(t, I(n)); const i = x[r + o]; return N(n, r, t + 1), x[r + o] = i, o }, doAccess(e, r) { if (-8 & r) return -28; const t = Ie.lookupPath(e, { follow: !0 }).node; if (!t) return -44; let n = ""; return 4 & r && (n += "r"), 2 & r && (n += "w"), 1 & r && (n += "x"), n && Ie.nodePermissions(t, n) ? -2 : 0 }, doReadv(e, r, t, n) { for (var o = 0, i = 0; i < t; i++) { const a = $[r >> 2]; const s = $[r + 4 >> 2]; r += 8; const l = Ie.read(e, x, a, s, n); if (l < 0) return -1; if (o += l, l < s) break } return o }, doWritev(e, r, t, n) { for (var o = 0, i = 0; i < t; i++) { const a = $[r >> 2]; const s = $[r + 4 >> 2]; r += 8; const l = Ie.write(e, x, a, s, n); if (l < 0) return -1; o += l } return o }, varargs: void 0, get() { return F(Le.varargs != null), Le.varargs += 4, $[Le.varargs - 4 >> 2] }, getStr(e) { return R(e) }, getStreamFromFD(e) { const r = Ie.getStream(e); if (!r) throw new Ie.ErrnoError(8); return r } }; function xe(e) { switch (e) { case 1:return 0; case 2:return 1; case 4:return 2; case 8:return 3; default:throw new TypeError(`Unknown type size: ${e}`) } } let Ue = void 0; function Be(e) { for (var r = "", t = e; U[t];)r += Ue[U[t++]]; return r } const je = {}; const $e = {}; const We = {}; function ze(e) { if (void 0 === e) return "_unknown"; const r = (e = e.replace(/\W/g, "$")).charCodeAt(0); return r >= 48 && r <= 57 ? `_${e}` : e } function He(e, r) { return e = ze(e), new Function("body", `return function ${e}() {\n    "use strict";    return body.apply(this, arguments);\n};\n`)(r) } function Ge(e, r) { const t = He(r, function (e) { this.name = r, this.message = e; const t = new Error(e).stack; void 0 !== t && (this.stack = `${this.toString()}\n${t.replace(/^Error(:[^\n]*)?\n/, "")}`) }); return t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.prototype.toString = function () { return void 0 === this.message ? this.name : `${this.name}: ${this.message}` }, t } let Ve = void 0; function Ye(e) { throw new Ve(e) } let qe = void 0; function Xe(e) { throw new qe(e) } function Ke(e, r, t) { function n(r) { const n = t(r); n.length !== e.length && Xe("Mismatched type converter count"); for (let o = 0; o < e.length; ++o)Je(e[o], n[o]) }e.forEach((e) => { We[e] = r }); const o = Array.from({ length: r.length }); const i = []; let a = 0; r.forEach((e, r) => { $e.hasOwnProperty(e) ? o[r] = $e[e] : (i.push(e), je.hasOwnProperty(e) || (je[e] = []), je[e].push(() => { o[r] = $e[e], ++a === i.length && n(o) })) }), i.length === 0 && n(o) } function Je(e, r) { const t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!("argPackAdvance" in r)) throw new TypeError("registerType registeredInstance requires argPackAdvance"); const n = r.name; if (e || Ye(`type "${n}" must have a positive integer typeid pointer`), $e.hasOwnProperty(e)) { if (t.ignoreDuplicateRegistrations) return; Ye(`Cannot register type '${n}' twice`) } if ($e[e] = r, delete We[e], je.hasOwnProperty(e)) { const o = je[e]; delete je[e], o.forEach(e => e()) } } function Qe(e) { if (!(this instanceof wr)) return !1; if (!(e instanceof wr)) return !1; for (var r = this.$$.ptrType.registeredClass, t = this.$$.ptr, n = e.$$.ptrType.registeredClass, o = e.$$.ptr; r.baseClass;)t = r.upcast(t), r = r.baseClass; for (;n.baseClass;)o = n.upcast(o), n = n.baseClass; return r === n && t === o } function Ze(e) { Ye(`${e.$$.ptrType.registeredClass.name} instance already deleted`) } let er = !1; function rr(e) {} function tr(e) { e.count.value -= 1, e.count.value === 0 && (function (e) { e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr) }(e)) } function nr(e, r, t) { if (r === t) return e; if (void 0 === t.baseClass) return null; const n = nr(e, r, t.baseClass); return n === null ? null : t.downcast(n) } const or = {}; function ir() { return Object.keys(dr).length } function ar() { const e = []; for (const r in dr)dr.hasOwnProperty(r) && e.push(dr[r]); return e } const sr = []; function lr() { for (;sr.length;) { const e = sr.pop(); e.$$.deleteScheduled = !1, e.delete() } } let ur = void 0; function cr(e) { ur = e, sr.length && ur && ur(lr) } var dr = {}; function fr(e, r) { return r = (function (e, r) { for (void 0 === r && Ye("ptr should not be undefined"); e.baseClass;)r = e.upcast(r), e = e.baseClass; return r }(e, r)), dr[r] } function pr(e, r) { return r.ptrType && r.ptr || Xe("makeClassHandle requires ptr and ptrType"), !!r.smartPtrType !== !!r.smartPtr && Xe("Both smartPtrType and smartPtr must be specified"), r.count = { value: 1 }, hr(Object.create(e, { $$: { value: r } })) } function mr(e) { const r = this.getPointee(e); if (!r) return this.destructor(e), null; const t = fr(this.registeredClass, r); if (void 0 !== t) { if (t.$$.count.value === 0) return t.$$.ptr = r, t.$$.smartPtr = e, t.clone(); const n = t.clone(); return this.destructor(e), n } function o() { return this.isSmartPointer ? pr(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: r, smartPtrType: this, smartPtr: e }) : pr(this.registeredClass.instancePrototype, { ptrType: this, ptr: e }) } let i; const a = this.registeredClass.getActualType(r); const s = or[a]; if (!s) return o.call(this); i = this.isConst ? s.constPointerType : s.pointerType; const l = nr(r, this.registeredClass, i.registeredClass); return l === null ? o.call(this) : this.isSmartPointer ? pr(i.registeredClass.instancePrototype, { ptrType: i, ptr: l, smartPtrType: this, smartPtr: e }) : pr(i.registeredClass.instancePrototype, { ptrType: i, ptr: l }) } function hr(e) { return typeof FinalizationRegistry == "undefined" ? (hr = e => e, e) : (er = new FinalizationRegistry((e) => { console.warn(e.leakWarning.stack.replace(/^Error: /, "")), tr(e.$$) }), hr = (e) => { const r = e.$$; if (r.smartPtr) { const t = { $$: r }; const n = r.ptrType.registeredClass; t.leakWarning = new Error(`Embind found a leaked C++ instance ${n.name} <0x${r.ptr.toString(16)}>.\nWe'll free it automatically in this case, but this functionality is not reliable across various environments.\nMake sure to invoke .delete() manually once you're done with the instance instead.\nOriginally allocated`), "captureStackTrace" in Error && Error.captureStackTrace(t.leakWarning, mr), er.register(e, t, e) } return e }, rr = e => er.unregister(e), hr(e)) } function gr() { if (this.$$.ptr || Ze(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this; let e; const r = hr(Object.create(Object.getPrototypeOf(this), { $$: { value: (e = this.$$, { count: e.count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType }) } })); return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r } function vr() { this.$$.ptr || Ze(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Ye("Object already scheduled for deletion"), rr(this), tr(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0) } function yr() { return !this.$$.ptr } function Er() { return this.$$.ptr || Ze(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Ye("Object already scheduled for deletion"), sr.push(this), sr.length === 1 && ur && ur(lr), this.$$.deleteScheduled = !0, this } function wr() {} function br(e, r, t) { if (void 0 === e[r].overloadTable) { const n = e[r]; e[r] = function () { return e[r].overloadTable.hasOwnProperty(arguments.length) || Ye(`Function '${t}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[r].overloadTable})!`), e[r].overloadTable[arguments.length].apply(this, arguments) }, e[r].overloadTable = [], e[r].overloadTable[n.argCount] = n } } function _r(e, r, t, n, o, i, a, s) { this.name = e, this.constructor = r, this.instancePrototype = t, this.rawDestructor = n, this.baseClass = o, this.getActualType = i, this.upcast = a, this.downcast = s, this.pureVirtualFunctions = [] } function Tr(e, r, t) { for (;r !== t;)r.upcast || Ye(`Expected null or instance of ${t.name}, got an instance of ${r.name}`), e = r.upcast(e), r = r.baseClass; return e } function kr(e, r) { if (r === null) return this.isReference && Ye(`null is not a valid ${this.name}`), 0; r.$$ || Ye(`Cannot pass "${qr(r)}" as a ${this.name}`), r.$$.ptr || Ye(`Cannot pass deleted object as a pointer of type ${this.name}`); const t = r.$$.ptrType.registeredClass; return Tr(r.$$.ptr, t, this.registeredClass) } function Sr(e, r) {
      let t; if (r === null) return this.isReference && Ye(`null is not a valid ${this.name}`), this.isSmartPointer ? (t = this.rawConstructor(), e !== null && e.push(this.rawDestructor, t), t) : 0; r.$$ || Ye(`Cannot pass "${qr(r)}" as a ${this.name}`), r.$$.ptr || Ye(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && r.$$.ptrType.isConst && Ye(`Cannot convert argument of type ${r.$$.smartPtrType ? r.$$.smartPtrType.name : r.$$.ptrType.name} to parameter type ${this.name}`); const n = r.$$.ptrType.registeredClass; if (t = Tr(r.$$.ptr, n, this.registeredClass), this.isSmartPointer) {
        switch (void 0 === r.$$.smartPtr && Ye("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:r.$$.smartPtrType === this ? t = r.$$.smartPtr : Ye(`Cannot convert argument of type ${r.$$.smartPtrType ? r.$$.smartPtrType.name : r.$$.ptrType.name} to parameter type ${this.name}`); break; case 1:t = r.$$.smartPtr; break; case 2:if (r.$$.smartPtrType === this) {
            t = r.$$.smartPtr;
          }
          else { const o = r.clone(); t = this.rawShare(t, Yr.toHandle(() => { o.delete() })), e !== null && e.push(this.rawDestructor, t) } break; default:Ye("Unsupporting sharing policy")
        }
      } return t
    } function Cr(e, r) { if (r === null) return this.isReference && Ye(`null is not a valid ${this.name}`), 0; r.$$ || Ye(`Cannot pass "${qr(r)}" as a ${this.name}`), r.$$.ptr || Ye(`Cannot pass deleted object as a pointer of type ${this.name}`), r.$$.ptrType.isConst && Ye(`Cannot convert argument of type ${r.$$.ptrType.name} to parameter type ${this.name}`); const t = r.$$.ptrType.registeredClass; return Tr(r.$$.ptr, t, this.registeredClass) } function Pr(e) { return this.fromWireType(W[e >> 2]) } function Ar(e) { return this.rawGetPointee && (e = this.rawGetPointee(e)), e } function Fr(e) { this.rawDestructor && this.rawDestructor(e) } function Dr(e) { e !== null && e.delete() } function Or(e, r, t, n, o, i, a, s, l, u, c) { this.name = e, this.registeredClass = r, this.isReference = t, this.isConst = n, this.isSmartPointer = o, this.pointeeType = i, this.sharingPolicy = a, this.rawGetPointee = s, this.rawConstructor = l, this.rawShare = u, this.rawDestructor = c, o || void 0 !== r.baseClass ? this.toWireType = Sr : n ? (this.toWireType = kr, this.destructorFunction = null) : (this.toWireType = Cr, this.destructorFunction = null) } function Rr(e, t, n) { return e.includes("j") ? (function (e, t, n) { F(`dynCall_${e}` in r, `bad function pointer type - no table for sig '${e}'`), n && n.length ? F(n.length === e.substring(1).replace(/j/g, "--").length) : F(e.length == 1); const o = r[`dynCall_${e}`]; return n && n.length ? o.apply(null, [t].concat(n)) : o.call(null, t) }(e, t, n)) : (F(Ce(t), `missing table entry in dynCall: ${t}`), Ce(t).apply(null, n)) } function Mr(e, r) { const t = (e = Be(e)).includes("j") ? (function (e, r) { F(e.includes("j"), "getDynCaller should only be called with i64 sigs"); const t = []; return function () { return t.length = 0, Object.assign(t, arguments), Rr(e, r, t) } }(e, r)) : Ce(r); return typeof t != "function" && Ye(`unknown function pointer with signature ${e}: ${r}`), t } let Nr = void 0; function Ir(e) { const r = Et(e); const t = Be(r); return ht(r), t } function Lr(e, r) { const t = []; const n = {}; throw r.forEach(function e(r) { n[r] || $e[r] || (We[r] ? We[r].forEach(e) : (t.push(r), n[r] = !0)) }), new Nr(`${e}: ${t.map(Ir).join([", "])}`) } function xr(e, r) { for (var t = [], n = 0; n < e; n++)t.push($[(r >> 2) + n]); return t } function Ur(e) { for (;e.length;) { const r = e.pop(); e.pop()(r) } } function Br(e, r) { if (!(e instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof e} which is not a function`); const t = He(e.name || "unknownFunctionName", () => {}); t.prototype = e.prototype; const n = new t(); const o = e.apply(n, r); return o instanceof Object ? o : n } function jr(e, r, t, n, o) {
      const i = r.length; i < 2 && Ye("argTypes array size mismatch! Must at least get return value and 'this' types!"); for (var a = r[1] !== null && t !== null, s = !1, l = 1; l < r.length; ++l) {
        if (r[l] !== null && void 0 === r[l].destructorFunction) { s = !0; break }
      } const u = r[0].name !== "void"; let c = ""; let d = ""; for (l = 0; l < i - 2; ++l)c += `${l !== 0 ? ", " : ""}arg${l}`, d += `${l !== 0 ? ", " : ""}arg${l}Wired`; let f = `return function ${ze(e)}(${c}) {\nif (arguments.length !== ${i - 2}) {\nthrowBindingError('function ${e} called with ' + arguments.length + ' arguments, expected ${i - 2} args!');\n}\n`; s && (f += "var destructors = [];\n"); const p = s ? "destructors" : "null"; const m = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"]; const h = [Ye, n, o, Ur, r[0], r[1]]; a && (f += `var thisWired = classParam.toWireType(${p}, this);\n`); for (l = 0; l < i - 2; ++l)f += `var arg${l}Wired = argType${l}.toWireType(${p}, arg${l}); // ${r[l + 2].name}\n`, m.push(`argType${l}`), h.push(r[l + 2]); if (a && (d = `thisWired${d.length > 0 ? ", " : ""}${d}`), f += `${u ? "var rv = " : ""}invoker(fn${d.length > 0 ? ", " : ""}${d});\n`, s) {
        f += "runDestructors(destructors);\n";
      }
      else {
        for (l = a ? 1 : 2; l < r.length; ++l) { const g = l === 1 ? "thisWired" : `arg${l - 2}Wired`; r[l].destructorFunction !== null && (f += `${g}_dtor(${g}); // ${r[l].name}\n`, m.push(`${g}_dtor`), h.push(r[l].destructorFunction)) }
      } return u && (f += "var ret = retType.fromWireType(rv);\nreturn ret;\n"), f += "}\n", m.push(f), Br(Function, m).apply(null, h)
    } function $r(e, r, t) { return e instanceof Object || Ye(`${t} with invalid "this": ${e}`), e instanceof r.registeredClass.constructor || Ye(`${t} incompatible with "this" of type ${e.constructor.name}`), e.$$.ptr || Ye(`cannot call emscripten binding method ${t} on deleted object`), Tr(e.$$.ptr, e.$$.ptrType.registeredClass, r.registeredClass) } const Wr = []; const zr = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }]; function Hr(e) { e > 4 && --zr[e].refcount == 0 && (zr[e] = void 0, Wr.push(e)) } function Gr() { for (var e = 0, r = 5; r < zr.length; ++r) void 0 !== zr[r] && ++e; return e } function Vr() {
      for (let e = 5; e < zr.length; ++e) {
        if (void 0 !== zr[e]) return zr[e];
      } return null
    } var Yr = { toValue: e => (e || Ye(`Cannot use deleted val. handle = ${e}`), zr[e].value), toHandle: (e) => { switch (e) { case void 0:return 1; case null:return 2; case !0:return 3; case !1:return 4; default:var r = Wr.length ? Wr.pop() : zr.length; return zr[r] = { refcount: 1, value: e }, r } } }; function qr(e) { if (e === null) return "null"; const r = typeof e; return r === "object" || r === "array" || r === "function" ? e.toString() : `${e}` } function Xr(e, r) { switch (r) { case 2:return function (e) { return this.fromWireType(z[e >> 2]) }; case 3:return function (e) { return this.fromWireType(H[e >> 3]) }; default:throw new TypeError(`Unknown float type: ${e}`) } } function Kr(e, r, t) { switch (r) { case 0:return t ? function (e) { return x[e] } : function (e) { return U[e] }; case 1:return t ? function (e) { return B[e >> 1] } : function (e) { return j[e >> 1] }; case 2:return t ? function (e) { return $[e >> 2] } : function (e) { return W[e >> 2] }; default:throw new TypeError(`Unknown integer type: ${e}`) } } function Jr(e, r) { const t = $e[e]; return void 0 === t && Ye(`${r} has unknown type ${Ir(e)}`), t } const Qr = {}; const Zr = []; const et = []; function rt(e, r) { return F(r === (0 | r)), (e >>> 0) + 4294967296 * r } function tt(e, r) { if (e <= 0) return e; const t = r <= 32 ? Math.abs(1 << r - 1) : 2 ** (r - 1); return e >= t && (r <= 32 || e > t) && (e = -2 * t + e), e } function nt(e, r) { return e >= 0 ? e : r <= 32 ? 2 * Math.abs(1 << r - 1) + e : 2 ** r + e } function ot(e, r) {
      F((3 & r) == 0); let t = e; let n = r; function o(e) { let r; return n = (function (e, r) { return r === "double" || r === "i64" ? 7 & e && (F((7 & e) == 4), e += 4) : F((3 & e) == 0), e }(n, e)), e === "double" ? (r = Number(H[n >> 3]), n += 8) : e == "i64" ? (r = [$[n >> 2], $[n + 4 >> 2]], n += 8) : (F((3 & n) == 0), e = "i32", r = $[n >> 2], n += 4), r } for (var i, a, s, l, u, c, d = []; ;) {
        const f = t; if ((i = x[t >> 0]) === 0) break; if (a = x[t + 1 >> 0], i == 37) {
          let p = !1; let m = !1; let h = !1; let g = !1; let v = !1; e:for (;;) { switch (a) { case 43:p = !0; break; case 45:m = !0; break; case 35:h = !0; break; case 48:if (g) break e; g = !0; break; case 32:v = !0; break; default:break e }t++, a = x[t + 1 >> 0] } let y = 0; if (a == 42) {
            y = o("i32"), t++, a = x[t + 1 >> 0];
          }
          else {
            for (;a >= 48 && a <= 57;)y = 10 * y + (a - 48), t++, a = x[t + 1 >> 0];
          } var E; let w = !1; let b = -1; if (a == 46) {
            if (b = 0, w = !0, t++, (a = x[t + 1 >> 0]) == 42) {
              b = o("i32"), t++;
            }
            else {
              for (;;) { const _ = x[t + 1 >> 0]; if (_ < 48 || _ > 57) break; b = 10 * b + (_ - 48), t++ }
            }a = x[t + 1 >> 0]
          } switch (b < 0 && (b = 6, w = !1), String.fromCharCode(a)) { case "h":x[t + 2 >> 0] == 104 ? (t++, E = 1) : E = 2; break; case "l":x[t + 2 >> 0] == 108 ? (t++, E = 8) : E = 4; break; case "L":case "q":case "j":E = 8; break; case "z":case "t":case "I":E = 4; break; default:E = null } switch (E && t++, a = x[t + 1 >> 0], String.fromCharCode(a)) {
            case "d":case "i":case "u":case "o":case "x":case "X":case "p":var T = a == 100 || a == 105; if (s = o(`i${8 * (E = E || 4)}`), E == 8 && (s = a == 117 ? (u = s[0], c = s[1], (u >>> 0) + 4294967296 * (c >>> 0)) : rt(s[0], s[1])), E <= 4)s = (T ? tt : nt)(s & 256 ** E - 1, 8 * E); var k = Math.abs(s); var S = ""; if (a == 100 || a == 105) {
              A = tt(s, 8 * E).toString(10);
            }
            else if (a == 117) {
              A = nt(s, 8 * E).toString(10), s = Math.abs(s);
            }
            else if (a == 111) {
              A = (h ? "0" : "") + k.toString(8);
            }
            else if (a == 120 || a == 88) {
              if (S = h && s != 0 ? "0x" : "", s < 0) { s = -s, A = (k - 1).toString(16); for (var C = [], P = 0; P < A.length; P++)C.push((15 - Number.parseInt(A[P], 16)).toString(16)); for (A = C.join(""); A.length < 2 * E;)A = `f${A}` }
              else {
                A = k.toString(16);
              }a == 88 && (S = S.toUpperCase(), A = A.toUpperCase())
            }
            else {
              a == 112 && (k === 0 ? A = "(nil)" : (S = "0x", A = k.toString(16)));
            } if (w) {
                for (;A.length < b;)A = `0${A}`;
              } for (s >= 0 && (p ? S = `+${S}` : v && (S = ` ${S}`)), A.charAt(0) == "-" && (S = `-${S}`, A = A.substr(1)); S.length + A.length < y;)m ? A += " " : g ? A = `0${A}` : S = ` ${S}`; (A = S + A).split("").forEach((e) => { d.push(e.charCodeAt(0)) }); break; case "f":case "F":case "e":case "E":case "g":case "G":var A; if (s = o("double"), isNaN(s)) {
              A = "nan", g = !1;
            }
            else if (isFinite(s)) {
              let D = !1; let O = Math.min(b, 20); if (a == 103 || a == 71) { D = !0, b = b || 1; const R = Number.parseInt(s.toExponential(O).split("e")[1], 10); b > R && R >= -4 ? (a = (a == 103 ? "f" : "F").charCodeAt(0), b -= R + 1) : (a = (a == 103 ? "e" : "E").charCodeAt(0), b--), O = Math.min(b, 20) }a == 101 || a == 69 ? (A = s.toExponential(O), /e[-+]\d$/i.test(A) && (A = `${A.slice(0, -1)}0${A.slice(-1)}`)) : a != 102 && a != 70 || (A = s.toFixed(O), s === 0 && ((l = s) < 0 || l === 0 && 1 / l == -1 / 0) && (A = `-${A}`)); const M = A.split("e"); if (D && !h) {
                for (;M[0].length > 1 && M[0].includes(".") && (M[0].slice(-1) == "0" || M[0].slice(-1) == ".");)M[0] = M[0].slice(0, -1);
              }
              else {
                for (h && !A.includes(".") && (M[0] += "."); b > O++;)M[0] += "0";
              }A = M[0] + (M.length > 1 ? `e${M[1]}` : ""), a == 69 && (A = A.toUpperCase()), s >= 0 && (p ? A = `+${A}` : v && (A = ` ${A}`))
            }
            else {
              A = `${s < 0 ? "-" : ""}inf`, g = !1;
            } for (;A.length < y;)m ? A += " " : A = !g || A[0] != "-" && A[0] != "+" ? (g ? "0" : " ") + A : `${A[0]}0${A.slice(1)}`; a < 97 && (A = A.toUpperCase()), A.split("").forEach((e) => { d.push(e.charCodeAt(0)) }); break; case "s":var N = o("i8*"); var I = N ? vt(N) : "(null)".length; if (w && (I = Math.min(I, b)), !m) {
              for (;I < y--;)d.push(32);
            } if (N) {
                for (P = 0; P < I; P++)d.push(U[N++ >> 0]);
              }
              else {
                d = d.concat(pt("(null)".substr(0, I), !0));
              } if (m) {
                for (;I < y--;)d.push(32);
              } break; case "c":for (m && d.push(o("i8")); --y > 0;)d.push(32); m || d.push(o("i8")); break; case "n":var L = o("i32*"); $[L >> 2] = d.length; break; case "%":d.push(i); break; default:for (P = f; P < t + 2; P++)d.push(x[P >> 0])
          }t += 2
        }
        else {
          d.push(i), t += 1
        }
      } return d
    } function it(e) { if (!e || !e.callee || !e.callee.name) return [null, "", ""]; e.callee.toString(); const r = e.callee.name; let t = "("; let n = !0; for (const o in e) { const i = e[o]; n || (t += ", "), n = !1, t += typeof i == "number" || typeof i == "string" ? i : `(${typeof i})` }t += ")"; const a = e.callee.caller; return n && (t = ""), [e = a ? a.arguments : [], r, t] } function at(e, r) {
      24 & e && (r = r.replace(/\s+$/, ""), r += (r.length > 0 ? "\n" : "") + (function (e) {
        let r = Pe(); const t = r.lastIndexOf("_emscripten_log"); const n = r.lastIndexOf("_emscripten_get_callstack"); const o = r.indexOf("\n", Math.max(t, n)) + 1; r = r.slice(o), 32 & e && T("EM_LOG_DEMANGLE is deprecated; ignoring"), 8 & e && typeof emscripten_source_map == "undefined" && (T('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.'), e ^= 8, e |= 16); let i = null; if (128 & e) {
          for (i = it(arguments); i[1].includes("_emscripten_");)i = it(i[0]);
        } const a = r.split("\n"); r = ""; const s = new RegExp("\\s*(.*?)@(.*?):(\\d+):(\\d+)"); const l = new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?"); const u = new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)"); for (const c in a) {
          const d = a[c]; let f = ""; let p = ""; let m = 0; let h = 0; let g = u.exec(d); if (g && g.length == 5) {
            f = g[1], p = g[2], m = g[3], h = g[4];
          }
          else { if ((g = s.exec(d)) || (g = l.exec(d)), !(g && g.length >= 4)) { r += `${d}\n`; continue }f = g[1], p = g[2], m = g[3], h = 0 | g[4] } let v = !1; if (8 & e) { const y = emscripten_source_map.originalPositionFor({ line: m, column: h }); (v = y && y.source) && (64 & e && (y.source = y.source.substring(y.source.replace(/\\/g, "/").lastIndexOf("/") + 1)), r += `    at ${f} (${y.source}:${y.line}:${y.column})\n`) }(16 & e || !v) && (64 & e && (p = p.substring(p.replace(/\\/g, "/").lastIndexOf("/") + 1)), r += `${v ? `     = ${f}` : `    at ${f}`} (${p}:${m}:${h})\n`), 128 & e && i[0] && (i[1] == f && i[2].length > 0 && (r = r.replace(/\s+$/, ""), r += ` with values: ${i[1]}${i[2]}\n`), i = it(i[0]))
        } return r.replace(/\s+$/, "")
      }(e))), 1 & e ? 4 & e ? console.error(r) : 2 & e ? console.warn(r) : 512 & e ? console.info(r) : 256 & e ? console.debug(r) : console.log(r) : 6 & e ? _(r) : b(r)
    } function st(e) {
      try { return w.grow(e - L.byteLength + 65535 >>> 16), Z(w.buffer), 1 }
      catch (r) { _(`emscripten_realloc_buffer: Attempted to grow heap from ${L.byteLength} bytes to ${e} bytes, but got error: ${r}`) }
    } const lt = {}; function ut() { if (!ut.strings) { const e = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: `${(typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_")}.UTF-8`, _: n || "./this.program" }; for (var r in lt) void 0 === lt[r] ? delete e[r] : e[r] = lt[r]; const t = []; for (var r in e)t.push(`${r}=${e[r]}`); ut.strings = t } return ut.strings } const ct = function (e, r, t, n) { e || (e = this), this.parent = e, this.mount = e.mount, this.mounted = null, this.id = Ie.nextInode++, this.name = r, this.mode = t, this.node_ops = {}, this.stream_ops = {}, this.rdev = n }; const dt = 365; const ft = 146; function pt(e, r, t) { const n = t > 0 ? t : I(e) + 1; const o = new Array(n); const i = M(e, o, 0, o.length); return r && (o.length = i), o }Object.defineProperties(ct.prototype, { read: { get() { return (this.mode & dt) === dt }, set(e) { e ? this.mode |= dt : this.mode &= -366 } }, write: { get() { return (this.mode & ft) === ft }, set(e) { e ? this.mode |= ft : this.mode &= -147 } }, isFolder: { get() { return Ie.isDir(this.mode) } }, isDevice: { get() { return Ie.isChrdev(this.mode) } } }), Ie.FSNode = ct, Ie.staticInit(), Ne = { EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135 }, (function () { for (var e = Array.from({ length: 256 }), r = 0; r < 256; ++r)e[r] = String.fromCharCode(r); Ue = e }()), Ve = r.BindingError = Ge(Error, "BindingError"), qe = r.InternalError = Ge(Error, "InternalError"), wr.prototype.isAliasOf = Qe, wr.prototype.clone = gr, wr.prototype.delete = vr, wr.prototype.isDeleted = yr, wr.prototype.deleteLater = Er, r.getInheritedInstanceCount = ir, r.getLiveInheritedInstances = ar, r.flushPendingDeletes = lr, r.setDelayFunction = cr, Or.prototype.getPointee = Ar, Or.prototype.destructor = Fr, Or.prototype.argPackAdvance = 8, Or.prototype.readValueFromPointer = Pr, Or.prototype.deleteObject = Dr, Or.prototype.fromWireType = mr, Nr = r.UnboundTypeError = Ge(Error, "UnboundTypeError"), r.count_emval_handles = Gr, r.get_first_emval = Vr; const mt = { __syscall_fcntl64(e, r, t) {
      Le.varargs = t; try { const n = Le.getStreamFromFD(e); switch (r) { case 0:return (o = Le.get()) < 0 ? -28 : Ie.createStream(n, o).fd; case 1:case 2:case 6:case 7:return 0; case 3:return n.flags; case 4:var o = Le.get(); return n.flags |= o, 0; case 5:o = Le.get(); return B[o + 0 >> 1] = 2, 0; case 16:case 8:default:return -28; case 9:return i = 28, $[yt() >> 2] = i, -1 } }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return -e.errno } let i
    }, __syscall_openat(e, r, t, n) {
      Le.varargs = n; try { r = Le.getStr(r), r = Le.calculateAt(e, r); const o = n ? Le.get() : 0; return Ie.open(r, t, o).fd }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return -e.errno }
    }, _embind_register_bigint(e, r, t, n, o) {}, _embind_register_bool(e, r, t, n, o) {
      const i = xe(t); Je(e, { name: r = Be(r), fromWireType(e) { return !!e }, toWireType(e, r) { return r ? n : o }, argPackAdvance: 8, readValueFromPointer(e) {
        let n; if (t === 1) {
          n = x;
        }
        else if (t === 2) {
          n = B;
        }
        else { if (t !== 4) throw new TypeError(`Unknown boolean type size: ${r}`); n = $ } return this.fromWireType(n[e >> i])
      }, destructorFunction: null })
    }, _embind_register_class(e, t, n, o, i, a, s, l, u, c, d, f, p) { d = Be(d), a = Mr(i, a), l && (l = Mr(s, l)), c && (c = Mr(u, c)), p = Mr(f, p); const m = ze(d); !(function (e, t, n) { r.hasOwnProperty(e) ? ((void 0 === n || void 0 !== r[e].overloadTable && void 0 !== r[e].overloadTable[n]) && Ye(`Cannot register public name '${e}' twice`), br(r, e, e), r.hasOwnProperty(n) && Ye(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`), r[e].overloadTable[n] = t) : (r[e] = t, void 0 !== n && (r[e].numArguments = n)) }(m, () => { Lr(`Cannot construct ${d} due to unbound types`, [o]) })), Ke([e, t, n], o ? [o] : [], (t) => { let n, i; t = t[0], i = o ? (n = t.registeredClass).instancePrototype : wr.prototype; const s = He(m, function () { if (Object.getPrototypeOf(this) !== u) throw new Ve(`Use 'new' to construct ${d}`); if (void 0 === f.constructor_body) throw new Ve(`${d} has no accessible constructor`); const e = f.constructor_body[arguments.length]; if (void 0 === e) throw new Ve(`Tried to invoke ctor of ${d} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(f.constructor_body).toString()}) parameters instead!`); return e.apply(this, arguments) }); var u = Object.create(i, { constructor: { value: s } }); s.prototype = u; var f = new _r(d, s, u, p, n, a, l, c); const h = new Or(d, f, !0, !1, !1); const g = new Or(`${d}*`, f, !1, !1, !1); const v = new Or(`${d} const*`, f, !1, !0, !1); return or[e] = { pointerType: g, constPointerType: v }, (function (e, t, n) { r.hasOwnProperty(e) || Xe("Replacing nonexistant public symbol"), void 0 !== r[e].overloadTable && void 0 !== n ? r[e].overloadTable[n] = t : (r[e] = t, r[e].argCount = n) }(m, s)), [h, g, v] }) }, _embind_register_class_constructor(e, r, t, n, o, i) { F(r > 0); const a = xr(r, t); o = Mr(n, o), Ke([], [e], (e) => { const t = `constructor ${(e = e[0]).name}`; if (void 0 === e.registeredClass.constructor_body && (e.registeredClass.constructor_body = []), void 0 !== e.registeredClass.constructor_body[r - 1]) throw new Ve(`Cannot register multiple constructors with identical number of parameters (${r - 1}) for class '${e.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`); return e.registeredClass.constructor_body[r - 1] = () => { Lr(`Cannot construct ${e.name} due to unbound types`, a) }, Ke([], a, (n) => { return n.splice(1, 0, null), e.registeredClass.constructor_body[r - 1] = jr(t, n, null, o, i), [] }), [] }) }, _embind_register_class_function(e, r, t, n, o, i, a, s) { const l = xr(t, n); r = Be(r), i = Mr(o, i), Ke([], [e], (e) => { const n = `${(e = e[0]).name}.${r}`; function o() { Lr(`Cannot call ${n} due to unbound types`, l) }r.startsWith("@@") && (r = Symbol[r.substring(2)]), s && e.registeredClass.pureVirtualFunctions.push(r); const u = e.registeredClass.instancePrototype; const c = u[r]; return void 0 === c || void 0 === c.overloadTable && c.className !== e.name && c.argCount === t - 2 ? (o.argCount = t - 2, o.className = e.name, u[r] = o) : (br(u, r, n), u[r].overloadTable[t - 2] = o), Ke([], l, (o) => { const s = jr(n, o, e, i, a); return void 0 === u[r].overloadTable ? (s.argCount = t - 2, u[r] = s) : u[r].overloadTable[t - 2] = s, [] }), [] }) }, _embind_register_class_property(e, r, t, n, o, i, a, s, l, u) { r = Be(r), o = Mr(n, o), Ke([], [e], (e) => { const n = `${(e = e[0]).name}.${r}`; const c = { get() { Lr(`Cannot access ${n} due to unbound types`, [t, a]) }, enumerable: !0, configurable: !0 }; return c.set = l ? () => { Lr(`Cannot access ${n} due to unbound types`, [t, a]) } : (e) => { Ye(`${n} is a read-only property`) }, Object.defineProperty(e.registeredClass.instancePrototype, r, c), Ke([], l ? [t, a] : [t], (t) => { const a = t[0]; const c = { get() { const r = $r(this, e, `${n} getter`); return a.fromWireType(o(i, r)) }, enumerable: !0 }; if (l) { l = Mr(s, l); const d = t[1]; c.set = function (r) { const t = $r(this, e, `${n} setter`); const o = []; l(u, t, d.toWireType(o, r)), Ur(o) } } return Object.defineProperty(e.registeredClass.instancePrototype, r, c), [] }), [] }) }, _embind_register_emval(e, r) { Je(e, { name: r = Be(r), fromWireType(e) { const r = Yr.toValue(e); return Hr(e), r }, toWireType(e, r) { return Yr.toHandle(r) }, argPackAdvance: 8, readValueFromPointer: Pr, destructorFunction: null }) }, _embind_register_float(e, r, t) { const n = xe(t); Je(e, { name: r = Be(r), fromWireType(e) { return e }, toWireType(e, r) { if (typeof r != "number" && typeof r != "boolean") throw new TypeError(`Cannot convert "${qr(r)}" to ${this.name}`); return r }, argPackAdvance: 8, readValueFromPointer: Xr(r, n), destructorFunction: null }) }, _embind_register_integer(e, r, t, n, o) { r = Be(r), o === -1 && (o = 4294967295); const i = xe(t); let a = e => e; if (n === 0) { const s = 32 - 8 * t; a = e => e << s >>> s } const l = r.includes("unsigned"); const u = (e, t) => { if (typeof e != "number" && typeof e != "boolean") throw new TypeError(`Cannot convert "${qr(e)}" to ${t}`); if (e < n || e > o) throw new TypeError(`Passing a number "${qr(e)}" from JS side to C/C++ side to an argument of type "${r}", which is outside the valid range [${n}, ${o}]!`) }; Je(e, { name: r, fromWireType: a, toWireType: l ? function (e, r) { return u(r, this.name), r >>> 0 } : function (e, r) { return u(r, this.name), r }, argPackAdvance: 8, readValueFromPointer: Kr(r, i, n !== 0), destructorFunction: null }) }, _embind_register_memory_view(e, r, t) { const n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][r]; function o(e) { const r = W; const t = r[e >>= 2]; const o = r[e + 1]; return new n(L, o, t) }Je(e, { name: t = Be(t), fromWireType: o, argPackAdvance: 8, readValueFromPointer: o }, { ignoreDuplicateRegistrations: !0 }) }, _embind_register_std_string(e, r) {
      const t = (r = Be(r)) === "std::string"; Je(e, { name: r, fromWireType(e) {
        let r; const n = W[e >> 2]; if (t) {
          for (var o = e + 4, i = 0; i <= n; ++i) { const a = e + 4 + i; if (i == n || U[a] == 0) { const s = R(o, a - o); void 0 === r ? r = s : (r += String.fromCharCode(0), r += s), o = a + 1 } }
        }
        else { const l = new Array(n); for (i = 0; i < n; ++i)l[i] = String.fromCharCode(U[e + 4 + i]); r = l.join("") } return ht(e), r
      }, toWireType(e, r) {
        r instanceof ArrayBuffer && (r = new Uint8Array(r)); const n = typeof r == "string"; n || r instanceof Uint8Array || r instanceof Uint8ClampedArray || r instanceof Int8Array || Ye("Cannot pass non-string to std::string"); const o = (t && n ? () => I(r) : () => r.length)(); const i = gt(4 + o + 1); if (W[i >> 2] = o, t && n) {
          N(r, i + 4, o + 1);
        }
        else if (n) {
          for (var a = 0; a < o; ++a) { const s = r.charCodeAt(a); s > 255 && (ht(i), Ye("String has UTF-16 code units that do not fit in 8 bits")), U[i + 4 + a] = s }
        }
        else {
          for (a = 0; a < o; ++a)U[i + 4 + a] = r[a];
        } return e !== null && e.push(ht, i), i
      }, argPackAdvance: 8, readValueFromPointer: Pr, destructorFunction(e) { ht(e) } })
    }, _embind_register_std_wstring(e, r, t) { let n, o, i, a, s; t = Be(t), r === 2 ? (n = V, o = Y, a = q, i = () => j, s = 1) : r === 4 && (n = X, o = K, a = J, i = () => W, s = 2), Je(e, { name: t, fromWireType(e) { for (var t, o = W[e >> 2], a = i(), l = e + 4, u = 0; u <= o; ++u) { const c = e + 4 + u * r; if (u == o || a[c >> s] == 0) { const d = n(l, c - l); void 0 === t ? t = d : (t += String.fromCharCode(0), t += d), l = c + r } } return ht(e), t }, toWireType(e, n) { typeof n != "string" && Ye(`Cannot pass non-string to C++ string type ${t}`); const i = a(n); const l = gt(4 + i + r); return W[l >> 2] = i >> s, o(n, l + 4, i + r), e !== null && e.push(ht, l), l }, argPackAdvance: 8, readValueFromPointer: Pr, destructorFunction(e) { ht(e) } }) }, _embind_register_void(e, r) { Je(e, { isVoid: !0, name: r = Be(r), argPackAdvance: 0, fromWireType() {}, toWireType(e, r) {} }) }, _emscripten_date_now() { return Date.now() }, _emval_as(e, r, t) { e = Yr.toValue(e), r = Jr(r, "emval::as"); const n = []; const o = Yr.toHandle(n); return $[t >> 2] = o, r.toWireType(n, e) }, _emval_call_void_method(e, r, t, n) { let o, i; (e = Zr[e])(r = Yr.toValue(r), t = void 0 === (i = Qr[o = t]) ? Be(o) : i, null, n) }, _emval_decref: Hr, _emval_get_method_caller(e, r) { const t = (function (e, r) { for (var t = new Array(e), n = 0; n < e; ++n)t[n] = Jr($[(r >> 2) + n], `parameter ${n}`); return t }(e, r)); const n = t[0]; const o = `${n.name}_$${t.slice(1).map((e) => { return e.name }).join("_")}$`; let i = et[o]; if (void 0 !== i) return i; for (var a = ["retType"], s = [n], l = "", u = 0; u < e - 1; ++u)l += `${u !== 0 ? ", " : ""}arg${u}`, a.push(`argType${u}`), s.push(t[1 + u]); let c = `return function ${ze(`methodCaller_${o}`)}(handle, name, destructors, args) {\n`; let d = 0; for (u = 0; u < e - 1; ++u)c += `    var arg${u} = argType${u}.readValueFromPointer(args${d ? `+${d}` : ""});\n`, d += t[u + 1].argPackAdvance; for (c += `    var rv = handle[name](${l});\n`, u = 0; u < e - 1; ++u)t[u + 1].deleteObject && (c += `    argType${u}.deleteObject(arg${u});\n`); n.isVoid || (c += "    return retType.toWireType(destructors, rv);\n"), c += "};\n", a.push(c); let f; let p; const m = Br(Function, a).apply(null, s); return f = m, p = Zr.length, Zr.push(f), i = p, et[o] = i, i }, _emval_incref(e) { e > 4 && (zr[e].refcount += 1) }, _emval_run_destructors(e) { Ur(Yr.toValue(e)), Hr(e) }, _emval_take_value(e, r) { const t = (e = Jr(e, "_emval_take_value")).readValueFromPointer(r); return Yr.toHandle(t) }, _gmtime_js(e, r) { const t = new Date(1e3 * $[e >> 2]); $[r >> 2] = t.getUTCSeconds(), $[r + 4 >> 2] = t.getUTCMinutes(), $[r + 8 >> 2] = t.getUTCHours(), $[r + 12 >> 2] = t.getUTCDate(), $[r + 16 >> 2] = t.getUTCMonth(), $[r + 20 >> 2] = t.getUTCFullYear() - 1900, $[r + 24 >> 2] = t.getUTCDay(); const n = Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0); const o = (t.getTime() - n) / 864e5 | 0; $[r + 28 >> 2] = o }, _localtime_js(e, r) { const t = new Date(1e3 * $[e >> 2]); $[r >> 2] = t.getSeconds(), $[r + 4 >> 2] = t.getMinutes(), $[r + 8 >> 2] = t.getHours(), $[r + 12 >> 2] = t.getDate(), $[r + 16 >> 2] = t.getMonth(), $[r + 20 >> 2] = t.getFullYear() - 1900, $[r + 24 >> 2] = t.getDay(); const n = new Date(t.getFullYear(), 0, 1); const o = (t.getTime() - n.getTime()) / 864e5 | 0; $[r + 28 >> 2] = o, $[r + 36 >> 2] = -60 * t.getTimezoneOffset(); const i = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(); const a = n.getTimezoneOffset(); const s = 0 | (i != a && t.getTimezoneOffset() == Math.min(a, i)); $[r + 32 >> 2] = s }, _mktime_js(e) {
      const r = new Date($[e + 20 >> 2] + 1900, $[e + 16 >> 2], $[e + 12 >> 2], $[e + 8 >> 2], $[e + 4 >> 2], $[e >> 2], 0); const t = $[e + 32 >> 2]; const n = r.getTimezoneOffset(); const o = new Date(r.getFullYear(), 0, 1); const i = new Date(r.getFullYear(), 6, 1).getTimezoneOffset(); const a = o.getTimezoneOffset(); const s = Math.min(a, i); if (t < 0) {
        $[e + 32 >> 2] = Number(i != a && s == n);
      }
      else if (t > 0 != (s == n)) { const l = Math.max(a, i); const u = t > 0 ? s : l; r.setTime(r.getTime() + 6e4 * (u - n)) }$[e + 24 >> 2] = r.getDay(); const c = (r.getTime() - o.getTime()) / 864e5 | 0; return $[e + 28 >> 2] = c, $[e >> 2] = r.getSeconds(), $[e + 4 >> 2] = r.getMinutes(), $[e + 8 >> 2] = r.getHours(), $[e + 12 >> 2] = r.getDate(), $[e + 16 >> 2] = r.getMonth(), r.getTime() / 1e3 | 0
    }, _tzset_js: function e(r, t, n) { e.called || (e.called = !0, (function (e, r, t) { const n = (new Date()).getFullYear(); const o = new Date(n, 0, 1); const i = new Date(n, 6, 1); const a = o.getTimezoneOffset(); const s = i.getTimezoneOffset(); const l = Math.max(a, s); function u(e) { const r = e.toTimeString().match(/\(([A-Z ]+)\)$/i); return r ? r[1] : "GMT" }$[e >> 2] = 60 * l, $[r >> 2] = Number(a != s); const c = u(o); const d = u(i); const f = Q(c); const p = Q(d); s < a ? ($[t >> 2] = f, $[t + 4 >> 2] = p) : ($[t >> 2] = p, $[t + 4 >> 2] = f) }(r, t, n))) }, abort() { ge("native code called abort()") }, emscripten_log(e, r, t) { at(e, O(ot(r, t), 0)) }, emscripten_resize_heap(e) { const r = U.length; F((e >>>= 0) > r); let t; let n; const o = 2147483648; if (e > o) return _(`Cannot enlarge memory, asked to go up to ${e} bytes, but the limit is ` + `2147483648 bytes!`), !1; for (let i = 1; i <= 4; i *= 2) { let a = r * (1 + 0.2 / i); a = Math.min(a, e + 100663296); var s = Math.min(o, (t = Math.max(e, a)) + ((n = 65536) - t % n) % n); if (st(s)) return !0 } return _(`Failed to grow the heap from ${r} bytes to ${s} bytes, not enough memory!`), !1 }, environ_get(e, r) { let t = 0; return ut().forEach((n, o) => { const i = r + t; $[e + 4 * o >> 2] = i, (function (e, r, t) { for (let n = 0; n < e.length; ++n)F(e.charCodeAt(n) === (255 & e.charCodeAt(n))), x[r++ >> 0] = e.charCodeAt(n); t || (x[r >> 0] = 0) }(n, i)), t += n.length + 1 }), 0 }, environ_sizes_get(e, r) { const t = ut(); $[e >> 2] = t.length; let n = 0; return t.forEach((e) => { n += e.length + 1 }), $[r >> 2] = n, 0 }, fd_close(e) {
      try { const r = Le.getStreamFromFD(e); return Ie.close(r), 0 }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return e.errno }
    }, fd_fdstat_get(e, r) {
      try { const t = Le.getStreamFromFD(e); const n = t.tty ? 2 : Ie.isDir(t.mode) ? 3 : Ie.isLink(t.mode) ? 7 : 4; return x[r >> 0] = n, 0 }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return e.errno }
    }, fd_read(e, r, t, n) {
      try { const o = Le.getStreamFromFD(e); const i = Le.doReadv(o, r, t); return $[n >> 2] = i, 0 }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return e.errno }
    }, fd_seek(e, r, t, n, o) {
      try { const i = Le.getStreamFromFD(e); const a = 4294967296 * t + (r >>> 0); const s = 9007199254740992; return a <= -s || a >= s ? -61 : (Ie.llseek(i, a, n), Ee = [i.position >>> 0, (ye = i.position, +Math.abs(ye) >= 1 ? ye > 0 ? (0 | Math.min(+Math.floor(ye / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ye - +(~~ye >>> 0)) / 4294967296) >>> 0 : 0)], $[o >> 2] = Ee[0], $[o + 4 >> 2] = Ee[1], i.getdents && a === 0 && n === 0 && (i.getdents = null), 0) }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return e.errno }
    }, fd_write(e, r, t, n) {
      try { const o = Le.getStreamFromFD(e); const i = Le.doWritev(o, r, t); return $[n >> 2] = i, 0 }
      catch (e) { if (void 0 === Ie || !(e instanceof Ie.ErrnoError)) throw e; return e.errno }
    }, setTempRet0(e) {} }; !(function () {
      const e = { env: mt, wasi_snapshot_preview1: mt }; function t(e, t) { let n; const o = e.exports; r.asm = o, F(w = r.asm.memory, "memory not found in wasm exports"), Z(w.buffer), F(re = r.asm.__indirect_function_table, "table not found in wasm exports"), n = r.asm.__wasm_call_ctors, ae.unshift(n), he("wasm-instantiate") }me("wasm-instantiate"); let n = r; function o(e) { F(r === n, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"), n = null, t(e.instance) } function i(r) { return (function () { if (!E && (s || l)) { if (typeof fetch == "function" && !be(ve)) return fetch(ve, { credentials: "same-origin" }).then((e) => { if (!e.ok) throw `failed to load wasm binary file at '${ve}'`; return e.arrayBuffer() }).catch(() => { return Te(ve) }); if (f) return new Promise((e, r) => { f(ve, (r) => { e(new Uint8Array(r)) }, r) }) } return Promise.resolve().then(() => { return Te(ve) }) }()).then((r) => { return WebAssembly.instantiate(r, e) }).then((e) => { return e }).then(r, (e) => { _(`failed to asynchronously prepare wasm: ${e}`), be(ve) && _(`warning: Loading from a file URI (${ve}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`), ge(e) }) } if (r.instantiateWasm) {
        try { return r.instantiateWasm(e, t) }
        catch (e) { return _(`Module.instantiateWasm callback failed with error: ${e}`), !1 }
      }E || typeof WebAssembly.instantiateStreaming != "function" || we(ve) || be(ve) || typeof fetch != "function" ? i(o) : fetch(ve, { credentials: "same-origin" }).then((r) => { return WebAssembly.instantiateStreaming(r, e).then(o, (e) => { return _(`wasm streaming compile failed: ${e}`), _("falling back to ArrayBuffer instantiation"), i(o) }) })
    }()), r.___wasm_call_ctors = _e("__wasm_call_ctors"); var ht = r._free = _e("free"); var gt = r._malloc = _e("malloc"); var vt = r._strlen = _e("strlen"); var yt = r.___errno_location = _e("__errno_location"); var Et = r.___getTypeName = _e("__getTypeName"); r.___embind_register_native_and_builtin_types = _e("__embind_register_native_and_builtin_types"); var wt = r.___stdio_exit = _e("__stdio_exit"); var bt = r._emscripten_builtin_memalign = _e("emscripten_builtin_memalign"); var _t = r._emscripten_stack_init = function () { return (_t = r._emscripten_stack_init = r.asm.emscripten_stack_init).apply(null, arguments) }; r._emscripten_stack_get_free = function () { return (r._emscripten_stack_get_free = r.asm.emscripten_stack_get_free).apply(null, arguments) }, r._emscripten_stack_get_base = function () { return (r._emscripten_stack_get_base = r.asm.emscripten_stack_get_base).apply(null, arguments) }; let Tt; var kt = r._emscripten_stack_get_end = function () { return (kt = r._emscripten_stack_get_end = r.asm.emscripten_stack_get_end).apply(null, arguments) }; function St(e) { this.name = "ExitStatus", this.message = `Program terminated with exit(${e})`, this.status = e } function Ct(e) {
      function t() {
        Tt || (Tt = !0, r.calledRun = !0, A || (oe(), F(!le), le = !0, r.noFSInit || Ie.init.initialized || Ie.init(), Ie.ignorePermissions = !1, ke(ae), r.onRuntimeInitialized && r.onRuntimeInitialized(), F(!r._main, 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'), (function () {
          if (oe(), r.postRun) {
            for (typeof r.postRun == "function" && (r.postRun = [r.postRun]); r.postRun.length;)e = r.postRun.shift(), se.unshift(e);
          } let e; ke(se)
        }())))
      }ue > 0 || (_t(), ne(), (function () {
        if (r.preRun) {
          for (typeof r.preRun == "function" && (r.preRun = [r.preRun]); r.preRun.length;)e = r.preRun.shift(), ie.unshift(e);
        } let e; ke(ie)
      }()), ue > 0 || (r.setStatus ? (r.setStatus("Running..."), setTimeout(() => { setTimeout(() => { r.setStatus("") }, 1), t() }, 1)) : t(), oe()))
    } if (r.stackSave = _e("stackSave"), r.stackRestore = _e("stackRestore"), r.stackAlloc = _e("stackAlloc"), r.dynCall_ijiii = _e("dynCall_ijiii"), r.dynCall_viiijj = _e("dynCall_viiijj"), r.dynCall_jij = _e("dynCall_jij"), r.dynCall_jii = _e("dynCall_jii"), r.dynCall_jiji = _e("dynCall_jiji"), r._ff_h264_cabac_tables = 112940, P("intArrayFromString", !1), P("intArrayToString", !1), P("ccall", !1), P("cwrap", !1), P("setValue", !1), P("getValue", !1), P("allocate", !1), P("UTF8ArrayToString", !1), P("UTF8ToString", !1), P("stringToUTF8Array", !1), P("stringToUTF8", !1), P("lengthBytesUTF8", !1), P("stackTrace", !1), P("addOnPreRun", !1), P("addOnInit", !1), P("addOnPreMain", !1), P("addOnExit", !1), P("addOnPostRun", !1), P("writeStringToMemory", !1), P("writeArrayToMemory", !1), P("writeAsciiToMemory", !1), P("addRunDependency", !0), P("removeRunDependency", !0), P("FS_createFolder", !1), P("FS_createPath", !0), P("FS_createDataFile", !0), P("FS_createPreloadedFile", !0), P("FS_createLazyFile", !0), P("FS_createLink", !1), P("FS_createDevice", !0), P("FS_unlink", !0), P("getLEB", !1), P("getFunctionTables", !1), P("alignFunctionTables", !1), P("registerFunctions", !1), P("addFunction", !1), P("removeFunction", !1), P("prettyPrint", !1), P("dynCall", !1), P("getCompilerSetting", !1), P("print", !1), P("printErr", !1), P("getTempRet0", !1), P("setTempRet0", !1), P("callMain", !1), P("abort", !1), P("keepRuntimeAlive", !1), P("ptrToString", !1), P("zeroMemory", !1), P("stringToNewUTF8", !1), P("emscripten_realloc_buffer", !1), P("ENV", !1), P("ERRNO_CODES", !1), P("ERRNO_MESSAGES", !1), P("setErrNo", !1), P("inetPton4", !1), P("inetNtop4", !1), P("inetPton6", !1), P("inetNtop6", !1), P("readSockaddr", !1), P("writeSockaddr", !1), P("DNS", !1), P("getHostByName", !1), P("Protocols", !1), P("Sockets", !1), P("getRandomDevice", !1), P("traverseStack", !1), P("UNWIND_CACHE", !1), P("convertPCtoSourceLocation", !1), P("readAsmConstArgsArray", !1), P("readAsmConstArgs", !1), P("mainThreadEM_ASM", !1), P("jstoi_q", !1), P("jstoi_s", !1), P("getExecutableName", !1), P("listenOnce", !1), P("autoResumeAudioContext", !1), P("dynCallLegacy", !1), P("getDynCaller", !1), P("dynCall", !1), P("setWasmTableEntry", !1), P("getWasmTableEntry", !1), P("handleException", !1), P("runtimeKeepalivePush", !1), P("runtimeKeepalivePop", !1), P("callUserCallback", !1), P("maybeExit", !1), P("safeSetTimeout", !1), P("asmjsMangle", !1), P("asyncLoad", !1), P("alignMemory", !1), P("mmapAlloc", !1), P("reallyNegative", !1), P("unSign", !1), P("reSign", !1), P("formatString", !1), P("PATH", !1), P("PATH_FS", !1), P("SYSCALLS", !1), P("getSocketFromFD", !1), P("getSocketAddress", !1), P("JSEvents", !1), P("registerKeyEventCallback", !1), P("specialHTMLTargets", !1), P("maybeCStringToJsString", !1), P("findEventTarget", !1), P("findCanvasEventTarget", !1), P("getBoundingClientRect", !1), P("fillMouseEventData", !1), P("registerMouseEventCallback", !1), P("registerWheelEventCallback", !1), P("registerUiEventCallback", !1), P("registerFocusEventCallback", !1), P("fillDeviceOrientationEventData", !1), P("registerDeviceOrientationEventCallback", !1), P("fillDeviceMotionEventData", !1), P("registerDeviceMotionEventCallback", !1), P("screenOrientation", !1), P("fillOrientationChangeEventData", !1), P("registerOrientationChangeEventCallback", !1), P("fillFullscreenChangeEventData", !1), P("registerFullscreenChangeEventCallback", !1), P("registerRestoreOldStyle", !1), P("hideEverythingExceptGivenElement", !1), P("restoreHiddenElements", !1), P("setLetterbox", !1), P("currentFullscreenStrategy", !1), P("restoreOldWindowedStyle", !1), P("softFullscreenResizeWebGLRenderTarget", !1), P("doRequestFullscreen", !1), P("fillPointerlockChangeEventData", !1), P("registerPointerlockChangeEventCallback", !1), P("registerPointerlockErrorEventCallback", !1), P("requestPointerLock", !1), P("fillVisibilityChangeEventData", !1), P("registerVisibilityChangeEventCallback", !1), P("registerTouchEventCallback", !1), P("fillGamepadEventData", !1), P("registerGamepadEventCallback", !1), P("registerBeforeUnloadEventCallback", !1), P("fillBatteryEventData", !1), P("battery", !1), P("registerBatteryEventCallback", !1), P("setCanvasElementSize", !1), P("getCanvasElementSize", !1), P("demangle", !1), P("demangleAll", !1), P("jsStackTrace", !1), P("stackTrace", !1), P("getEnvStrings", !1), P("checkWasiClock", !1), P("writeI53ToI64", !1), P("writeI53ToI64Clamped", !1), P("writeI53ToI64Signaling", !1), P("writeI53ToU64Clamped", !1), P("writeI53ToU64Signaling", !1), P("readI53FromI64", !1), P("readI53FromU64", !1), P("convertI32PairToI53", !1), P("convertU32PairToI53", !1), P("dlopenMissingError", !1), P("setImmediateWrapped", !1), P("clearImmediateWrapped", !1), P("polyfillSetImmediate", !1), P("uncaughtExceptionCount", !1), P("exceptionLast", !1), P("exceptionCaught", !1), P("ExceptionInfo", !1), P("exception_addRef", !1), P("exception_decRef", !1), P("Browser", !1), P("setMainLoop", !1), P("wget", !1), P("FS", !1), P("MEMFS", !1), P("TTY", !1), P("PIPEFS", !1), P("SOCKFS", !1), P("_setNetworkCallback", !1), P("tempFixedLengthArray", !1), P("miniTempWebGLFloatBuffers", !1), P("heapObjectForWebGLType", !1), P("heapAccessShiftForWebGLHeap", !1), P("GL", !1), P("emscriptenWebGLGet", !1), P("computeUnpackAlignedImageSize", !1), P("emscriptenWebGLGetTexPixelData", !1), P("emscriptenWebGLGetUniform", !1), P("webglGetUniformLocation", !1), P("webglPrepareUniformLocationsBeforeFirstUse", !1), P("webglGetLeftBracePos", !1), P("emscriptenWebGLGetVertexAttrib", !1), P("writeGLArray", !1), P("AL", !1), P("SDL_unicode", !1), P("SDL_ttfContext", !1), P("SDL_audio", !1), P("SDL", !1), P("SDL_gfx", !1), P("GLUT", !1), P("EGL", !1), P("GLFW_Window", !1), P("GLFW", !1), P("GLEW", !1), P("IDBStore", !1), P("runAndAbortIfError", !1), P("InternalError", !1), P("BindingError", !1), P("UnboundTypeError", !1), P("PureVirtualError", !1), P("init_embind", !1), P("throwInternalError", !1), P("throwBindingError", !1), P("throwUnboundTypeError", !1), P("ensureOverloadTable", !1), P("exposePublicSymbol", !1), P("replacePublicSymbol", !1), P("extendError", !1), P("createNamedFunction", !1), P("registeredInstances", !1), P("getBasestPointer", !1), P("registerInheritedInstance", !1), P("unregisterInheritedInstance", !1), P("getInheritedInstance", !1), P("getInheritedInstanceCount", !1), P("getLiveInheritedInstances", !1), P("registeredTypes", !1), P("awaitingDependencies", !1), P("typeDependencies", !1), P("registeredPointers", !1), P("registerType", !1), P("whenDependentTypesAreResolved", !1), P("embind_charCodes", !1), P("embind_init_charCodes", !1), P("readLatin1String", !1), P("getTypeName", !1), P("heap32VectorToArray", !1), P("requireRegisteredType", !1), P("getShiftFromSize", !1), P("integerReadValueFromPointer", !1), P("enumReadValueFromPointer", !1), P("floatReadValueFromPointer", !1), P("simpleReadValueFromPointer", !1), P("runDestructors", !1), P("new_", !1), P("craftInvokerFunction", !1), P("embind__requireFunction", !1), P("tupleRegistrations", !1), P("structRegistrations", !1), P("genericPointerToWireType", !1), P("constNoSmartPtrRawPointerToWireType", !1), P("nonConstNoSmartPtrRawPointerToWireType", !1), P("init_RegisteredPointer", !1), P("RegisteredPointer", !1), P("RegisteredPointer_getPointee", !1), P("RegisteredPointer_destructor", !1), P("RegisteredPointer_deleteObject", !1), P("RegisteredPointer_fromWireType", !1), P("runDestructor", !1), P("releaseClassHandle", !1), P("finalizationRegistry", !1), P("detachFinalizer_deps", !1), P("detachFinalizer", !1), P("attachFinalizer", !1), P("makeClassHandle", !1), P("init_ClassHandle", !1), P("ClassHandle", !1), P("ClassHandle_isAliasOf", !1), P("throwInstanceAlreadyDeleted", !1), P("ClassHandle_clone", !1), P("ClassHandle_delete", !1), P("deletionQueue", !1), P("ClassHandle_isDeleted", !1), P("ClassHandle_deleteLater", !1), P("flushPendingDeletes", !1), P("delayFunction", !1), P("setDelayFunction", !1), P("RegisteredClass", !1), P("shallowCopyInternalPointer", !1), P("downcastPointer", !1), P("upcastPointer", !1), P("validateThis", !1), P("char_0", !1), P("char_9", !1), P("makeLegalFunctionName", !1), P("emval_handle_array", !1), P("emval_free_list", !1), P("emval_symbols", !1), P("init_emval", !1), P("count_emval_handles", !1), P("get_first_emval", !1), P("getStringOrSymbol", !1), P("Emval", !1), P("emval_newers", !1), P("craftEmvalAllocator", !1), P("emval_get_global", !1), P("emval_methodCallers", !1), P("emval_registeredMethods", !1), P("warnOnce", !1), P("stackSave", !1), P("stackRestore", !1), P("stackAlloc", !1), P("AsciiToString", !1), P("stringToAscii", !1), P("UTF16ToString", !1), P("stringToUTF16", !1), P("lengthBytesUTF16", !1), P("UTF32ToString", !1), P("stringToUTF32", !1), P("lengthBytesUTF32", !1), P("allocateUTF8", !1), P("allocateUTF8OnStack", !1), r.writeStackCookie = ne, r.checkStackCookie = oe, C("ALLOC_NORMAL", !1), C("ALLOC_STACK", !1), de = function e() { Tt || Ct(), Tt || (de = e) }, r.run = Ct, r.preInit) {
      for (typeof r.preInit == "function" && (r.preInit = [r.preInit]); r.preInit.length > 0;)r.preInit.pop()();
    } Ct(), e.exports = r
  }); const u = 1e3; const c = 1e3; const d = !1; const f = !1; const p = !1; const m = !1; const h = "initVideo"; const g = "render"; const v = "playAudio"; const y = "initAudio"; const E = "audioCode"; const w = "videoCode"; const b = 1; const _ = 2; const T = "init"; const k = "decode"; const S = "audioDecode"; const C = "videoDecode"; const P = "close"; const A = "updateConfig"; const F = "key"; const D = "delta"; s((e) => {
    !(function () {
      const r = typeof window != "undefined" && void 0 !== window.document ? window.document : {}; const t = e.exports; const n = (function () {
        for (var e, t = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]], n = 0, o = t.length, i = {}; n < o; n++) {
          if ((e = t[n]) && e[1] in r) { for (n = 0; n < e.length; n++)i[t[0][n]] = e[n]; return i }
        } return !1
      }()); const o = { change: n.fullscreenchange, error: n.fullscreenerror }; const i = { request(e, t) { return new Promise((o, i) => { var a = function () { this.off("change", a), o() }.bind(this); this.on("change", a); const s = (e = e || r.documentElement)[n.requestFullscreen](t); s instanceof Promise && s.then(a).catch(i) }) }, exit() {
        return new Promise((e, t) => {
          if (this.isFullscreen) { var o = function () { this.off("change", o), e() }.bind(this); this.on("change", o); const i = r[n.exitFullscreen](); i instanceof Promise && i.then(o).catch(t) }
          else {
            e()
          }
        })
      }, toggle(e, r) { return this.isFullscreen ? this.exit() : this.request(e, r) }, onchange(e) { this.on("change", e) }, onerror(e) { this.on("error", e) }, on(e, t) { const n = o[e]; n && r.addEventListener(n, t, !1) }, off(e, t) { const n = o[e]; n && r.removeEventListener(n, t, !1) }, raw: n }; n ? (Object.defineProperties(i, { isFullscreen: { get() { return Boolean(r[n.fullscreenElement]) } }, element: { enumerable: !0, get() { return r[n.fullscreenElement] } }, isEnabled: { enumerable: !0, get() { return Boolean(r[n.fullscreenEnabled]) } } }), t ? e.exports = i : window.screenfull = i) : t ? e.exports = { isEnabled: !1 } : window.screenfull = { isEnabled: !1 }
    }())
  }).isEnabled, (() => {
    try { if (typeof WebAssembly == "object" && typeof WebAssembly.instantiate == "function") { const e = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)); if (e instanceof WebAssembly.Module) return new WebAssembly.Instance(e) instanceof WebAssembly.Instance } }
    catch (e) {}
  })(), Date.now || (Date.now = function () { return (new Date()).getTime() }), l.postRun = function () {
    let e = []; let r = []; let t = {}; "VideoEncoder" in self && (t = { hasInit: !1, isEmitInfo: !1, offscreenCanvas: null, offscreenCanvasCtx: null, decoder: new VideoDecoder({ output(e) { t.isEmitInfo || (n.opt.debug && console.log("Jessibuca: [worker] Webcodecs Video Decoder initSize"), postMessage({ cmd: h, w: e.codedWidth, h: e.codedHeight }), t.isEmitInfo = !0, t.offscreenCanvas = new OffscreenCanvas(e.codedWidth, e.codedHeight), t.offscreenCanvasCtx = t.offscreenCanvas.getContext("2d")), t.offscreenCanvasCtx.drawImage(e, 0, 0, e.codedWidth, e.codedHeight); const r = t.offscreenCanvas.transferToImageBitmap(); postMessage({ cmd: g, buffer: r, delay: n.delay, ts: 0 }, [r]), setTimeout(() => { e.close ? e.close() : e.destroy() }, 100) }, error(e) { console.error(e) } }), decode(e, r) {
      const o = e[0] >> 4 == 1; if (t.hasInit) { const n = new EncodedVideoChunk({ data: e.slice(5), timestamp: r, type: o ? F : D }); t.decoder.decode(n) }
      else if (o && e[1] === 0) { const r = 15 & e[0]; n.setVideoCodec(r); const o = (function (e) { const r = e.subarray(1, 4); let t = "avc1."; for (let e = 0; e < 3; e++) { let n = r[e].toString(16); n.length < 2 && (n = `0${n}`), t += n } return { codec: t, description: e } }(e.slice(5))); t.decoder.configure(o), t.hasInit = !0 }
    }, reset() { t.hasInit = !1, t.isEmitInfo = !1, t.offscreenCanvas = null, t.offscreenCanvasCtx = null } }); var n = { opt: { debug: d, useOffscreen: p, useWCS: f, videoBuffer: u, openWebglAlignment: m, videoBufferDelay: c }, useOffscreen() { return n.opt.useOffscreen && typeof OffscreenCanvas != "undefined" }, initAudioPlanar(e, t) { postMessage({ cmd: y, sampleRate: t, channels: e }); const n = []; let o = 0; this.playAudioPlanar = function (t, i, a) { for (var s = i, u = [], c = 0, d = 0; d < 2; d++) { const f = l.HEAPU32[(t >> 2) + d] >> 2; u[d] = l.HEAPF32.subarray(f, f + s) } if (o) { if (!(s >= (i = 1024 - o))) return o += s, r[0] = Float32Array.of(...r[0], ...u[0]), void (e == 2 && (r[1] = Float32Array.of(...r[1], ...u[1]))); n[0] = Float32Array.of(...r[0], ...u[0].subarray(0, i)), e == 2 && (n[1] = Float32Array.of(...r[1], ...u[1].subarray(0, i))), postMessage({ cmd: v, buffer: n, ts: a }, n.map(e => e.buffer)), c = i, s -= i } for (o = s; o >= 1024; o -= 1024)n[0] = u[0].slice(c, c += 1024), e == 2 && (n[1] = u[1].slice(c - 1024, c)), postMessage({ cmd: v, buffer: n, ts: a }, n.map(e => e.buffer)); o && (r[0] = u[0].slice(c), e == 2 && (r[1] = u[1].slice(c))) } }, setVideoCodec(e) { postMessage({ cmd: w, code: e }) }, setAudioCodec(e) { postMessage({ cmd: E, code: e }) }, setVideoSize(e, r) {
      postMessage({ cmd: h, w: e, h: r }); const t = e * r; const o = t >> 2; n.useOffscreen()
        ? (this.offscreenCanvas = new OffscreenCanvas(e, r), this.offscreenCanvasGL = this.offscreenCanvas.getContext("webgl"), this.webglObj = ((e, r) => {
            const t = ["attribute vec4 vertexPos;", "attribute vec4 texturePos;", "varying vec2 textureCoord;", "void main()", "{", "gl_Position = vertexPos;", "textureCoord = texturePos.xy;", "}"].join("\n"); const n = ["precision highp float;", "varying highp vec2 textureCoord;", "uniform sampler2D ySampler;", "uniform sampler2D uSampler;", "uniform sampler2D vSampler;", "const mat4 YUV2RGB = mat4", "(", "1.1643828125, 0, 1.59602734375, -.87078515625,", "1.1643828125, -.39176171875, -.81296875, .52959375,", "1.1643828125, 2.017234375, 0, -1.081390625,", "0, 0, 0, 1", ");", "void main(void) {", "highp float y = texture2D(ySampler,  textureCoord).r;", "highp float u = texture2D(uSampler,  textureCoord).r;", "highp float v = texture2D(vSampler,  textureCoord).r;", "gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;", "}"].join("\n"); r && e.pixelStorei(e.UNPACK_ALIGNMENT, 1); const o = e.createShader(e.VERTEX_SHADER); e.shaderSource(o, t), e.compileShader(o), e.getShaderParameter(o, e.COMPILE_STATUS) || console.log(`Vertex shader failed to compile: ${e.getShaderInfoLog(o)}`); const i = e.createShader(e.FRAGMENT_SHADER); e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS) || console.log(`Fragment shader failed to compile: ${e.getShaderInfoLog(i)}`); const a = e.createProgram(); e.attachShader(a, o), e.attachShader(a, i), e.linkProgram(a), e.getProgramParameter(a, e.LINK_STATUS) || console.log(`Program failed to compile: ${e.getProgramInfoLog(a)}`), e.useProgram(a); const s = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW); const l = e.getAttribLocation(a, "vertexPos"); e.enableVertexAttribArray(l), e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0); const u = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, u), e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), e.STATIC_DRAW); const c = e.getAttribLocation(a, "texturePos"); function d(r, t) { const n = e.createTexture(); return e.bindTexture(e.TEXTURE_2D, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.bindTexture(e.TEXTURE_2D, null), e.uniform1i(e.getUniformLocation(a, r), t), n }e.enableVertexAttribArray(c), e.vertexAttribPointer(c, 2, e.FLOAT, !1, 0, 0); const f = d("ySampler", 0); const p = d("uSampler", 1); const m = d("vSampler", 2); return { render(r, t, n, o, i) { e.viewport(0, 0, r, t), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, f), e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, r, t, 0, e.LUMINANCE, e.UNSIGNED_BYTE, n), e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, p), e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, r / 2, t / 2, 0, e.LUMINANCE, e.UNSIGNED_BYTE, o), e.activeTexture(e.TEXTURE2), e.bindTexture(e.TEXTURE_2D, m), e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, r / 2, t / 2, 0, e.LUMINANCE, e.UNSIGNED_BYTE, i), e.drawArrays(e.TRIANGLE_STRIP, 0, 4) }, destroy() {
              try { e.deleteProgram(a), e.deleteBuffer(s), e.deleteBuffer(u), e.deleteTexture(f), e.deleteTexture(p), e.deleteTexture(m) }
              catch (e) {}
            } }
          })(this.offscreenCanvasGL, n.opt.openWebglAlignment), this.draw = function (n, i, a, s) { const u = l.HEAPU8.subarray(i, i + t); const c = l.HEAPU8.subarray(a, a + o); const d = l.HEAPU8.subarray(s, s + o); this.webglObj.render(e, r, u, c, d); const f = this.offscreenCanvas.transferToImageBitmap(); postMessage({ cmd: g, buffer: f, delay: this.delay, ts: n }, [f]) })
        : this.draw = function (e, r, n, i) { const a = [Uint8Array.from(l.HEAPU8.subarray(r, r + t)), Uint8Array.from(l.HEAPU8.subarray(n, n + o)), Uint8Array.from(l.HEAPU8.subarray(i, i + o))]; postMessage({ cmd: g, output: a, delay: this.delay, ts: e }, a.map(e => e.buffer)) }
    }, getDelay(e) {
      if (!e) return -1; if (this.firstTimestamp) { if (e) { const r = Date.now() - this.startTimestamp; const t = e - this.firstTimestamp; this.delay = r >= t ? r - t : t - r } }
      else {
        this.firstTimestamp = e, this.startTimestamp = Date.now(), this.delay = -1;
      } return this.delay
    }, resetDelay() { this.firstTimestamp = null, this.startTimestamp = null, this.delay = -1 }, init() {
      n.opt.debug && console.log("Jessibuca: [worker] init"); const r = (e) => { n.opt.useWCS && n.useOffscreen() && e.type === _ && t.decode ? t.decode(e.payload, e.ts) : e.decoder.decode(e.payload, e.ts) }; this.stopId = setInterval(() => {
        if (e.length) {
          if (this.dropping) { for ((t = e.shift()).type === b && t.payload[1] === 0 && r(t); !t.isIFrame && e.length;)(t = e.shift()).type === b && t.payload[1] === 0 && r(t); t.isIFrame && (this.dropping = !1, r(t)) }
          else {
            var t = e[0]; if (this.getDelay(t.ts) === -1) {
              e.shift(), r(t);
            }
            else if (this.delay > n.opt.videoBuffer + n.opt.videoBufferDelay) {
              this.resetDelay(), this.dropping = !0;
            }
            else {
              for (;e.length && (t = e[0], this.getDelay(t.ts) > n.opt.videoBuffer);)e.shift(), r(t)
            }
          }
        }
      }, 10)
    }, close() { n.opt.debug && console.log("Jessibuca: [worker]: close"), clearInterval(this.stopId), this.stopId = null, o.clear && o.clear(), i.clear && i.clear(), t.reset && t.reset(), this.firstTimestamp = null, this.startTimestamp = null, this.delay = -1, this.dropping = !1, this.webglObj && (this.webglObj.destroy(), this.offscreenCanvas = null, this.offscreenCanvasGL = null, this.offscreenCanvasCtx = null), e = [], r = [], delete this.playAudioPlanar, delete this.draw }, pushBuffer(r, t) { t.type === b ? e.push({ ts: t.ts, payload: r, decoder: o, type: b }) : t.type === _ && e.push({ ts: t.ts, payload: r, decoder: i, type: _, isIFrame: t.isIFrame }) } }; var o = new l.AudioDecoder(n); var i = new l.VideoDecoder(n); postMessage({ cmd: T }), self.onmessage = function (e) {
      const r = e.data; switch (r.cmd) {
        case T:try { n.opt = Object.assign(n.opt, JSON.parse(r.opt)) }
        catch (e) {}o.sample_rate = r.sampleRate, n.init(); break; case k:n.pushBuffer(r.buffer, r.options); break; case S:o.decode(r.buffer, r.ts); break; case C:i.decode(r.buffer, r.ts); break; case P:n.close(); break; case A:n.opt[r.key] = r.value
      }
    }
  }
}));
